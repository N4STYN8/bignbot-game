<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bignbot TD</title>
  <style>
    :root{
      --bg:#0a0d12;
      --panel:#0e141b;
      --panel2:#111a23;
      --stroke:#ffffff22;
      --txt:#eaf1ff;
      --muted:#a9b4d6;

      /* ‚Äúwar UI‚Äù accents (like your reference art) */
      --gold:#f2c14f;
      --red:#ff4d4d;
      --green:#59ff7a;
      --cyan:#53e6ff;

      --shadow: 0 18px 60px #000000aa;
      --r:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 800px at 50% 10%, #1a2330 0%, transparent 55%),
        radial-gradient(900px 700px at 25% 15%, #1b2a1f 0%, transparent 60%),
        radial-gradient(900px 700px at 80% 25%, #2a1b1b 0%, transparent 60%),
        linear-gradient(180deg, #070a0f, #0a0d12);
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }

    /* Frame */
    .hud{
      position:fixed;
      inset:0;
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap:12px;
      padding:12px;
      max-width: 1800px;
      margin:0 auto;
    }

    /* Top bar (like the reference) */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      pointer-events:none; /* only buttons re-enable */
    }

    .chipbar{
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px 10px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, #141c25cc, #0c1219cc);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }

    .resource{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 14px;
      border:1px solid #ffffff18;
      background: linear-gradient(180deg, #1a222dcc, #0d131acc);
      min-width: 110px;
    }
    .resource .icon{
      width:22px;height:22px;border-radius:6px;
      display:grid;place-items:center;
      background:#0b0f14;
      border:1px solid #ffffff22;
    }
    .resource .val{
      font-weight:900;
      letter-spacing:.2px;
    }
    .resource.gold .val{ color: var(--gold); text-shadow: 0 0 10px #f2c14f33; }
    .resource.red  .val{ color: var(--red);  text-shadow: 0 0 10px #ff4d4d33; }
    .resource.green .val{ color: var(--green); text-shadow: 0 0 10px #59ff7a33; }

    .midinfo{
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px 10px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, #141c25cc, #0c1219cc);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .midinfo .title{
      font-weight:1000;
      letter-spacing:.2px;
    }
    .midinfo .sub{
      color:var(--muted);
      font-weight:800;
      font-size:12px;
    }
    .midinfo .sep{opacity:.35}

    /* Center playfield */
    #gameWrap{
      position:relative;
      border-radius: 22px;
      border:1px solid #ffffff20;
      box-shadow: var(--shadow);
      overflow:hidden;
      background:
        radial-gradient(900px 700px at 50% 0%, #53e6ff16, transparent 55%),
        radial-gradient(900px 700px at 85% 25%, #ff4d4d12, transparent 55%),
        linear-gradient(180deg, #0b1017, #070a0f);
    }
    canvas{
      position:absolute; left:0; top:0;
      width:100%; height:100%;
    }

    /* Bottom build bar (icons like your art) */
    .bottombar{
      display:flex;
      align-items:stretch;
      justify-content:space-between;
      gap:12px;
      pointer-events:none;
    }

    .buildbar{
      flex:1;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, #151e29dd, #0b1118dd);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      overflow:hidden;
      pointer-events:auto;
    }

    .towerGrid{
      display:flex;
      gap:10px;
      overflow:hidden;
      flex-wrap:nowrap;
    }

    .tile{
      width:90px;
      height:78px;
      border-radius: 14px;
      border:1px solid #ffffff1f;
      background: linear-gradient(180deg, #202a35, #0f151e);
      box-shadow: 0 10px 24px #00000066;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:8px;
      cursor:pointer;
      user-select:none;
      position:relative;
    }
    .tile:hover{ transform: translateY(-1px); border-color:#ffffff4a; }
    .tile:active{ transform: translateY(0px); }
    .tile.selected{ outline:2px solid #53e6ff66; border-color:#53e6ff88; }
    .tile.locked{ opacity:.45; cursor:not-allowed; }
    .tile .label{
      font-weight:1000;
      font-size:12px;
      letter-spacing:.2px;
    }
    .tile .cost{
      position:absolute;
      right:8px; bottom:8px;
      font-weight:1000;
      font-size:12px;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid #ffffff26;
      background:#0b0f14cc;
      color: var(--gold);
    }
    .tile .cap{
      position:absolute;
      left:8px; bottom:8px;
      font-weight:900;
      font-size:11px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #ffffff20;
      background:#0b0f14cc;
      color: #d9e2ff;
      opacity:.9;
    }

    .rightbar{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, #151e29dd, #0b1118dd);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }

    .btn{
      cursor:pointer;
      border-radius: 14px;
      padding:10px 12px;
      border:1px solid #ffffff28;
      background: linear-gradient(180deg, #1f2833, #0f151e);
      color:var(--txt);
      font-weight:1000;
      letter-spacing:.2px;
      box-shadow: 0 10px 22px #00000055;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-width: 110px;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color:#ffffff52; }
    .btn:active{ transform: translateY(0px); }
    .btn[disabled]{opacity:.45; cursor:not-allowed; transform:none;}
    .btn.primary{ border-color:#53e6ff55; box-shadow: 0 0 0 1px #53e6ff22, 0 14px 30px #53e6ff10; }
    .btn.danger{ border-color:#ff4d4d55; box-shadow: 0 0 0 1px #ff4d4d22, 0 14px 30px #ff4d4d10; }
    .btn.gold{ border-color:#f2c14f55; box-shadow: 0 0 0 1px #f2c14f22, 0 14px 30px #f2c14f10; }

    .mini{
      color:var(--muted);
      font-size:12px;
      font-weight:800;
      white-space:nowrap;
    }

    /* Small overlay help + toast */
    .toast{
      position:absolute;
      left:14px; bottom:14px;
      background:#0c1118e6;
      border:1px solid #53e6ff40;
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      font-size:12px;
      color:var(--txt);
      box-shadow: 0 12px 30px #00000080;
      display:none;
      max-width: 560px;
    }
    .toast.show{display:block;}
    .toast b{ color:var(--cyan); }

    .loading{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      flex-direction:column;
      gap:12px;
      background: linear-gradient(180deg, #0b1017, #070a0f);
      z-index:5;
    }
    .loading .big{
      font-weight:1100;
      font-size:18px;
      letter-spacing:.2px;
    }
    .bar{
      width:min(520px, 80%);
      height:10px;
      border-radius:999px;
      border:1px solid #ffffff22;
      background:#0b0f14cc;
      overflow:hidden;
    }
    .bar > i{
      display:block;
      height:100%;
      width:0%;
      background: linear-gradient(90deg, #53e6ff, #f2c14f, #ff4d4d);
    }

    /* Responsive: keep no-scroll; shrink tiles */
    @media (max-width: 1200px){
      .tile{ width:78px; height:74px; }
      .btn{ min-width: 96px; padding:10px 10px; }
      .resource{ min-width: 96px; }
      .midinfo .title{ font-size: 14px; }
    }
    @media (max-width: 980px){
      .topbar{ flex-wrap:wrap; }
      .bottombar{ flex-wrap:wrap; }
      .buildbar{ order:2; width:100%; }
      .rightbar{ order:1; width:100%; justify-content:space-between; }
      .towerGrid{ justify-content:space-between; width:100%; }
      .tile{ flex:1; min-width: 70px; max-width: 110px; }
    }
  </style>
</head>
<body>

  <div class="hud">
    <!-- TOP BAR -->
    <div class="topbar">
      <div class="chipbar" title="Resources">
        <div class="resource gold">
          <div class="icon">üí∞</div>
          <div class="val" id="cash">0</div>
        </div>
        <div class="resource red">
          <div class="icon">‚ù§</div>
          <div class="val" id="lives">0</div>
        </div>
        <div class="resource green">
          <div class="icon">üëæ</div>
          <div class="val" id="enemyCount">0</div>
        </div>
      </div>

      <div class="midinfo">
        <div>
          <div class="title" id="mapName">Training Grounds</div>
          <div class="sub">
            Wave <b id="waveNum">0</b>/<b id="waveMax">25</b>
            <span class="sep">‚Ä¢</span>
            Next: <b id="nextWave">READY</b>
          </div>
        </div>
        <div class="sep">|</div>
        <div class="mini">
          MAP <b id="mapIdx">1</b>/<b id="mapTotal">3</b>
          <span class="sep">‚Ä¢</span>
          SPEED <b id="speedLabel">1x</b>
          <span class="sep">‚Ä¢</span>
          <b id="runState">RUN</b>
        </div>
      </div>

      <div class="chipbar">
        <button class="btn" id="btnPause">Pause</button>
        <button class="btn primary" id="btnRange">Range: ON</button>
      </div>
    </div>

    <!-- GAME -->
    <div id="gameWrap">
      <canvas id="c"></canvas>
      <div class="loading" id="loading">
        <div class="big">Loading Bignbot TD assets‚Ä¶</div>
        <div class="bar"><i id="loadBar"></i></div>
        <div class="mini" id="loadText">Preparing sprites</div>
      </div>
      <div class="toast" id="toast"></div>
    </div>

    <!-- BOTTOM BAR -->
    <div class="bottombar">
      <div class="buildbar">
        <div class="towerGrid" id="towerGrid"></div>
        <div class="mini" style="margin-left:auto; opacity:.9;">
          Click a tower, then click the map to place. Right-click cancels.
        </div>
      </div>

      <div class="rightbar">
        <button class="btn gold" id="btnStartWave">Start Wave</button>
        <button class="btn primary" id="btnSkip" disabled>Skip Timer</button>

        <button class="btn" id="btnSpd1">1x</button>
        <button class="btn" id="btnSpd2">2x</button>
        <button class="btn" id="btnSpd3">3x</button>
        <button class="btn danger" id="btnSpd4">4x</button>

        <button class="btn danger" id="btnRestart">HOLD RESTART (1.2s)</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // RESPONSIVE LETTERBOX WORLD
  // ============================================================
  const BASE_W = 1600, BASE_H = 900;

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  const wrap = document.getElementById('gameWrap');

  let viewW=1, viewH=1, scale=1, offX=0, offY=0;

  function resize(){
    const r = wrap.getBoundingClientRect();
    viewW = Math.max(1, Math.floor(r.width));
    viewH = Math.max(1, Math.floor(r.height));

    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(viewW * dpr);
    canvas.height = Math.floor(viewH * dpr);
    canvas.style.width = viewW + 'px';
    canvas.style.height = viewH + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);

    scale = Math.min(viewW/BASE_W, viewH/BASE_H);
    offX = (viewW - BASE_W*scale)/2;
    offY = (viewH - BASE_H*scale)/2;
  }
  window.addEventListener('resize', resize);

  function screenToWorld(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const mx = clientX - r.left;
    const my = clientY - r.top;
    return { x:(mx - offX)/scale, y:(my - offY)/scale };
  }
  function inWorld(x,y){ return x>=0 && y>=0 && x<=BASE_W && y<=BASE_H; }

  // ============================================================
  // ASSETS (expects /assets/* from your zip)
  // ============================================================
  const loadingEl = document.getElementById('loading');
  const loadBar = document.getElementById('loadBar');
  const loadText = document.getElementById('loadText');
  const toastEl = document.getElementById('toast');

  const SPR = { turrets:{}, enemies:{}, proj:{}, icons:{} };

  const TURRET_TYPES = [
    { id:"basic",  name:"Marine", cost:60,  dmg:14, rng:145, cd:0.52, proj:"bullet", cap:999, unlockMap:1 },
    { id:"rapid",  name:"Tesla",  cost:90,  dmg:7,  rng:120, cd:0.16, proj:"bullet", cap:999, unlockMap:1 },
    { id:"sniper", name:"Rail",   cost:135, dmg:52, rng:260, cd:1.25, proj:"laser",  cap:6,   unlockMap:1 },
    { id:"splash", name:"Mortar", cost:140, dmg:20, rng:165, cd:1.25, proj:"shell",  cap:5,   unlockMap:1 },

    { id:"tesla",  name:"Chain",  cost:170, dmg:13, rng:150, cd:0.50, proj:"pulse",  cap:4,   unlockMap:2 },
    { id:"rail",   name:"Pierce", cost:210, dmg:75, rng:290, cd:1.55, proj:"laser",  cap:3,   unlockMap:3 },
    { id:"flame",  name:"Flame",  cost:160, dmg:9,  rng:115, cd:0.12, proj:"bullet", cap:4,   unlockMap:3 },
  ];
  const ENEMY_KINDS = ["grunt","runner","tank","shield","boss"];

  const ASSET_LIST = [];
  for(const t of TURRET_TYPES){
    for(const lvl of [1,2,3]){
      ASSET_LIST.push({url:`assets/turret_${t.id}_lvl${lvl}.png`, kind:"turret", id:t.id, lvl});
    }
  }
  for(const k of ENEMY_KINDS){
    for(const tier of [1,2,3]){
      ASSET_LIST.push({url:`assets/enemy_${k}_t${tier}.png`, kind:"enemy", id:k, tier});
    }
  }
  for(const p of ["bullet","laser","pulse","shell"]){
    ASSET_LIST.push({url:`assets/proj_${p}.png`, kind:"proj", id:p});
  }

  function loadImage(url){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.onload = ()=>resolve(im);
      im.onerror = ()=>reject(new Error("Missing: "+url));
      im.src = url;
    });
  }

  function toast(msg, ms=1300){
    toastEl.innerHTML = msg;
    toastEl.classList.add('show');
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>toastEl.classList.remove('show'), ms);
  }

  async function loadAssets(){
    let done=0, total=ASSET_LIST.length;
    for(const a of ASSET_LIST){
      loadText.textContent = a.url;
      loadBar.style.width = Math.floor((done/total)*100)+"%";
      try{
        const im = await loadImage(a.url);
        if(a.kind==="turret"){
          SPR.turrets[a.id] ??= {};
          SPR.turrets[a.id][a.lvl] = im;
        }else if(a.kind==="enemy"){
          SPR.enemies[a.id] ??= {};
          SPR.enemies[a.id][a.tier] = im;
        }else if(a.kind==="proj"){
          SPR.proj[a.id] = im;
        }
      }catch(e){
        console.warn(e);
      }
      done++;
    }
    loadBar.style.width = "100%";
    loadingEl.style.display = "none";
  }

  // ============================================================
  // MAPS (campaign auto-advance)
  // ============================================================
  const MAPS = [
    { name:"Training Grounds", waves:25, path:[
      {x:120,y:610},{x:420,y:610},{x:420,y:470},{x:520,y:470},
      {x:520,y:250},{x:880,y:250},{x:880,y:610},{x:1330,y:610},{x:1480,y:610}
    ]},
    { name:"Outpost Ridge", waves:25, path:[
      {x:120,y:300},{x:360,y:300},{x:360,y:720},{x:740,y:720},{x:740,y:340},
      {x:1060,y:340},{x:1060,y:600},{x:1480,y:600}
    ]},
    { name:"Broken Canyon", waves:25, path:[
      {x:120,y:670},{x:520,y:670},{x:520,y:520},{x:320,y:520},{x:320,y:260},
      {x:980,y:260},{x:980,y:520},{x:1180,y:520},{x:1180,y:700},{x:1480,y:700}
    ]},
  ];

  function pathSegments(path){
    const segs=[]; let total=0;
    for(let i=0;i<path.length-1;i++){
      const a=path[i], b=path[i+1];
      const dx=b.x-a.x, dy=b.y-a.y;
      const len=Math.hypot(dx,dy);
      segs.push({a,b,dx,dy,len,acc:total});
      total += len;
    }
    return {segs,total};
  }
  function posOnPath(pd, dist){
    const d=Math.max(0, Math.min(pd.total, dist));
    for(const s of pd.segs){
      if(d <= s.acc+s.len){
        const t=(d-s.acc)/s.len;
        return {x:s.a.x+s.dx*t, y:s.a.y+s.dy*t, ang:Math.atan2(s.dy,s.dx)};
      }
    }
    const last=pd.segs[pd.segs.length-1];
    return {x:last.b.x, y:last.b.y, ang:Math.atan2(last.dy,last.dx)};
  }

  // ============================================================
  // BALANCE + WAVES (kept strong)
  // ============================================================
  function turretStats(typeId, lvl){
    const t = TURRET_TYPES.find(x=>x.id===typeId);
    const mult = 1 + (lvl-1)*0.22;        // mild
    const rng = t.rng + (lvl-1)*18;
    const dmg = Math.round(t.dmg * mult);
    const cd  = Math.max(0.06, t.cd * (1 - (lvl-1)*0.08));
    return {dmg,rng,cd};
  }
  function enemyBase(kind){
    switch(kind){
      case "grunt": return {hp:60, spd:55, bounty:7};
      case "runner":return {hp:40, spd:92, bounty:8};
      case "tank":  return {hp:160, spd:40, bounty:14};
      case "shield":return {hp:95, spd:52, bounty:12, shield:70};
      case "boss":  return {hp:520, spd:34, bounty:55, boss:true};
      default: return {hp:60, spd:55, bounty:7};
    }
  }
  function wavePlan(wave){
    const tier = (wave<=8)?1:(wave<=17)?2:3;
    let list=[];
    const add=(kind,n,gap)=>{ for(let i=0;i<n;i++) list.push({kind,tier,delay:i*gap}); };

    if(wave===1) add("grunt",10,0.55);
    else if(wave===2){ add("grunt",8,0.48); add("runner",6,0.62); }
    else if(wave===3) add("grunt",12,0.42);
    else if(wave===4) add("runner",12,0.38);
    else if(wave===5){ add("tank",5,1.05); add("grunt",8,0.45); }
    else if(wave===6){ add("shield",6,0.85); add("runner",10,0.40); }
    else if(wave===7) add("tank",7,0.95);
    else if(wave===8){ add("boss",1,0.0); add("grunt",14,0.35); }
    else{
      const baseN = 12 + Math.floor(wave*0.9);
      const runners = Math.floor(baseN*0.33);
      const grunts  = Math.floor(baseN*0.40);
      const tanks   = Math.max(2, Math.floor(baseN*0.12));
      const shields = Math.max(2, Math.floor(baseN*0.14));

      add("grunt", grunts, 0.35 - Math.min(0.10, wave*0.004));
      list = list.map((e,i)=> ({...e, delay:e.delay + (i%3)*0.06}));
      for(let i=0;i<runners;i++) list.push({kind:"runner", tier, delay:i*0.32 + 0.8});
      for(let i=0;i<shields;i++) list.push({kind:"shield", tier, delay:i*0.62 + 1.6});
      for(let i=0;i<tanks;i++)   list.push({kind:"tank", tier, delay:i*0.90 + 2.2});
      if(wave%5===0) list.push({kind:"boss", tier, delay:3.2});
    }

    list.sort((a,b)=>a.delay-b.delay);
    for(const e of list){
      const base = enemyBase(e.kind);
      const hpMult = 1 + (wave-1)*0.08;
      const tierMult = 1 + (e.tier-1)*0.22;
      e.hp = Math.round(base.hp * hpMult * tierMult);
      e.spd = base.spd * (1 + (e.tier-1)*0.06);
      e.bounty = Math.round(base.bounty * (1 + (e.tier-1)*0.12));
      if(base.shield) e.shield = Math.round(base.shield * (1 + (wave-1)*0.06));
      e.boss = !!base.boss;
    }
    return {tier,enemies:list};
  }

  // ============================================================
  // STATE
  // ============================================================
  let enemyId=1, turretId=1, projId=1;

  const state = {
    mapIndex:0,
    wave:0,
    cash:220,
    lives:22,
    speed:1,
    paused:false,
    showRange:true,

    turrets:[],
    enemies:[],
    projectiles:[],

    buildPick:null,
    selectedTurretId:null,

    inWave:false,
    nextWaveTimer:0,
    allowSkip:false,
    spawnQueue:null,

    powerCounts:{},
    mouseWorld:null,
  };

  function currentMap(){ return MAPS[state.mapIndex]; }

  // ============================================================
  // UI ELEMENTS
  // ============================================================
  const ui = {
    cash: document.getElementById('cash'),
    lives: document.getElementById('lives'),
    enemyCount: document.getElementById('enemyCount'),

    mapName: document.getElementById('mapName'),
    waveNum: document.getElementById('waveNum'),
    waveMax: document.getElementById('waveMax'),
    nextWave: document.getElementById('nextWave'),
    mapIdx: document.getElementById('mapIdx'),
    mapTotal: document.getElementById('mapTotal'),
    speedLabel: document.getElementById('speedLabel'),
    runState: document.getElementById('runState'),

    btnPause: document.getElementById('btnPause'),
    btnRange: document.getElementById('btnRange'),
    btnStartWave: document.getElementById('btnStartWave'),
    btnSkip: document.getElementById('btnSkip'),

    btnSpd1: document.getElementById('btnSpd1'),
    btnSpd2: document.getElementById('btnSpd2'),
    btnSpd3: document.getElementById('btnSpd3'),
    btnSpd4: document.getElementById('btnSpd4'),

    btnRestart: document.getElementById('btnRestart'),
    towerGrid: document.getElementById('towerGrid'),
  };

  function syncUI(){
    const m = currentMap();
    ui.cash.textContent = state.cash;
    ui.lives.textContent = state.lives;
    ui.enemyCount.textContent = state.enemies.length;

    ui.mapName.textContent = m.name;
    ui.waveNum.textContent = state.wave;
    ui.waveMax.textContent = m.waves;
    ui.mapIdx.textContent = state.mapIndex+1;
    ui.mapTotal.textContent = MAPS.length;
    ui.speedLabel.textContent = state.speed+"x";
    ui.runState.textContent = state.paused ? "PAUSED" : "RUN";

    if(state.inWave) ui.nextWave.textContent = "IN WAVE";
    else if(state.wave===0) ui.nextWave.textContent = "READY";
    else if(state.nextWaveTimer>0) ui.nextWave.textContent = Math.ceil(state.nextWaveTimer)+"s";
    else ui.nextWave.textContent = "READY";

    // Wave flow: wave 1 manual; after that auto (skip timer allowed)
    ui.btnStartWave.disabled = state.inWave || (state.wave>=1 && state.wave < m.waves);
    ui.btnSkip.disabled = !(state.allowSkip && !state.inWave && state.wave>=1 && state.wave<m.waves);

    ui.btnRange.textContent = "Range: " + (state.showRange ? "ON" : "OFF");
    ui.btnRange.classList.toggle('primary', state.showRange);
  }

  // ============================================================
  // BUILD BAR
  // ============================================================
  function rebuildBuildBar(){
    ui.towerGrid.innerHTML = "";
    const unlockedMap = state.mapIndex+1;

    for(const t of TURRET_TYPES){
      const locked = unlockedMap < t.unlockMap;
      const isSelected = state.buildPick === t.id;
      const isPower = t.cap < 999;
      const count = state.powerCounts[t.id] || 0;

      const tile = document.createElement('div');
      tile.className = "tile" + (locked ? " locked" : "") + (isSelected ? " selected" : "");
      tile.innerHTML = `
        <div class="label">${t.name}</div>
        <div class="cost">$${t.cost}</div>
        <div class="cap">${isPower ? `${count}/${t.cap}` : "‚àû"}</div>
      `;
      if(!locked){
        tile.addEventListener('click', ()=>{
          state.buildPick = (state.buildPick===t.id) ? null : t.id;
          rebuildBuildBar();
          toast(state.buildPick ? `Selected <b>${t.name}</b> ‚Äî click map to place` : "Build canceled");
        });
      }
      ui.towerGrid.appendChild(tile);
    }
  }

  // ============================================================
  // GAME FLOW
  // ============================================================
  function resetCampaign(){
    state.mapIndex=0;
    state.wave=0;
    state.cash=220;
    state.lives=22;
    state.speed=1;
    state.paused=false;
    state.showRange=true;
    state.turrets=[];
    state.enemies=[];
    state.projectiles=[];
    state.buildPick=null;
    state.selectedTurretId=null;
    state.inWave=false;
    state.nextWaveTimer=0;
    state.allowSkip=false;
    state.spawnQueue=null;
    state.powerCounts={};
    rebuildBuildBar();
    syncUI();
    toast("Ready. <b>Start Wave</b> to begin.");
  }

  function beginMap(idx){
    state.mapIndex=idx;
    state.wave=0;
    state.inWave=false;
    state.nextWaveTimer=0;
    state.allowSkip=false;
    state.spawnQueue=null;
    state.enemies=[];
    state.projectiles=[];
    rebuildBuildBar();
    syncUI();
    toast(`Entering <b>${currentMap().name}</b>. Wave 1 is manual.`);
  }

  function victory(){
    toast("<b>VICTORY!</b> Campaign cleared.", 2200);
    state.paused = true;
    syncUI();
  }

  function defeat(){
    toast("<b>DEFEAT.</b> Hold restart to try again.", 2200);
    state.paused = true;
    syncUI();
  }

  function startWave(){
    if(state.inWave) return;
    const m = currentMap();

    if(state.wave >= m.waves){
      const next = state.mapIndex+1;
      if(next >= MAPS.length) victory();
      else beginMap(next);
      return;
    }

    state.wave++;
    state.inWave = true;
    state.allowSkip = false;

    const plan = wavePlan(state.wave);
    const pd = pathSegments(m.path);
    state.spawnQueue = plan.enemies.map(e=>({ ...e, t:e.delay, pathData:pd }));

    toast(`Wave <b>${state.wave}</b> started.`);
    syncUI();
  }

  function onWaveEnded(){
    state.inWave = false;
    const m = currentMap();

    if(state.wave >= m.waves){
      // map complete ‚Üí advance quickly
      state.nextWaveTimer = 2.0;
      state.allowSkip = false;
      toast("Map cleared. Advancing‚Ä¶", 1300);
      return;
    }

    state.nextWaveTimer = 30.0;
    state.allowSkip = true;
    toast("Wave cleared. Next wave in <b>30s</b> (or skip).", 1400);
    syncUI();
  }

  // ============================================================
  // PLACEMENT
  // ============================================================
  function canPlaceHere(x,y){
    const path = currentMap().path;
    const minDist = 44;
    for(let i=0;i<path.length-1;i++){
      const a=path[i], b=path[i+1];
      const t = ((x-a.x)*(b.x-a.x)+(y-a.y)*(b.y-a.y))/((b.x-a.x)**2+(b.y-a.y)**2);
      const tt=Math.max(0,Math.min(1,t));
      const px=a.x+(b.x-a.x)*tt, py=a.y+(b.y-a.y)*tt;
      if(Math.hypot(x-px,y-py) < minDist) return false;
    }
    for(const t of state.turrets){
      if(Math.hypot(x-t.x, y-t.y) < 52) return false;
    }
    return true;
  }

  function placeTurret(typeId,x,y){
    const tt = TURRET_TYPES.find(t=>t.id===typeId);
    if(!tt) return;

    state.powerCounts[typeId] ??= 0;
    const isPower = tt.cap < 999;
    if(isPower && state.powerCounts[typeId] >= tt.cap){
      toast(`Cap reached for <b>${tt.name}</b>.`);
      return;
    }
    if(state.cash < tt.cost){
      toast("Not enough cash.");
      return;
    }
    if(!canPlaceHere(x,y)){
      toast("Can't place there.");
      return;
    }

    state.cash -= tt.cost;

    const turret = {
      id: turretId++,
      typeId,
      x,y,
      lvl:1,
      cdLeft:0,
      rot:0
    };
    state.turrets.push(turret);
    if(isPower) state.powerCounts[typeId]++;

    state.selectedTurretId = turret.id;
    syncUI();
    rebuildBuildBar();
  }

  // ============================================================
  // COMBAT
  // ============================================================
  function spawnEnemy(kind,tier,hp,spd,bounty,shield,boss,pathData){
    const en = {
      id: enemyId++,
      kind,tier,
      hp, spd, bounty,
      shield: shield||0,
      boss: !!boss,
      dist: 0,
      x:0,y:0,ang:0,
      pathData,
      dead:false
    };
    const p = posOnPath(pathData,0);
    en.x=p.x; en.y=p.y; en.ang=p.ang;
    state.enemies.push(en);
  }

  function dealDamage(e,dmg){
    let left=dmg;
    if(e.shield>0){
      const s = Math.min(e.shield,left);
      e.shield -= s;
      left -= s;
    }
    if(left>0) e.hp -= left;
    if(e.hp<=0){
      e.dead=true;
      state.cash += e.bounty;
    }
  }

  function fireProjectile(kind,turret,target,dmg,opt){
    const muzzle=34;
    const sx = turret.x + Math.cos(turret.rot)*muzzle;
    const sy = turret.y + Math.sin(turret.rot)*muzzle;

    if(kind==="laser"){
      const p = { id:projId++, kind:"laser", x:sx,y:sy, tx:target.x,ty:target.y, rot:turret.rot, dmg, life:0.10, pierce:opt.pierce||0, lineWidth:opt.lineWidth||10, dead:false, hitIds:new Set() };
      applyLaserHits(p);
      state.projectiles.push(p);
      return;
    }

    const p = {
      id:projId++,
      kind,
      x:sx,y:sy,
      tx:target.x, ty:target.y,
      spd: 820,
      dmg,
      splash: opt.splash||0,
      chain: opt.chain||0,
      chainRange: opt.chainRange||0,
      pierce: opt.pierce||0,
      t:0,
      dead:false,
      hitIds:new Set()
    };
    state.projectiles.push(p);
  }

  function applyLaserHits(p){
    const ax=p.x, ay=p.y, bx=p.tx, by=p.ty;
    const abx=bx-ax, aby=by-ay;
    const abLen=Math.hypot(abx,aby)||1;
    const width=p.lineWidth||10;

    const candidates=[];
    for(const e of state.enemies){
      const apx=e.x-ax, apy=e.y-ay;
      const t=(apx*abx + apy*aby)/(abLen*abLen);
      if(t<0 || t>1) continue;
      const px=ax+abx*t, py=ay+aby*t;
      if(Math.hypot(e.x-px,e.y-py) <= width) candidates.push({e,t});
    }
    candidates.sort((a,b)=>a.t-b.t);

    let hits=0;
    const maxHits=1+(p.pierce||0);
    for(const c of candidates){
      if(hits>=maxHits) break;
      if(p.hitIds.has(c.e.id)) continue;
      p.hitIds.add(c.e.id);
      dealDamage(c.e,p.dmg);
      hits++;
    }
  }

  function impact(p){
    if(p.kind==="shell" && p.splash){
      for(const e of state.enemies){
        const d=Math.hypot(e.x-p.x, e.y-p.y);
        if(d<=p.splash){
          const fall=1-(d/p.splash);
          dealDamage(e, Math.round(p.dmg*(0.65+fall*0.35)));
        }
      }
      return;
    }
    if(p.kind==="pulse" && p.chain){
      // hit closest then chain
      let best=null, bestD=999;
      for(const e of state.enemies){
        const d=Math.hypot(e.x-p.x,e.y-p.y);
        if(d<bestD){ bestD=d; best=e; }
      }
      if(best && bestD<28){
        dealDamage(best,p.dmg);
        const near = state.enemies
          .filter(e=>e.id!==best.id && Math.hypot(e.x-best.x,e.y-best.y) <= (p.chainRange||120))
          .sort((a,b)=>Math.hypot(a.x-best.x,a.y-best.y)-Math.hypot(b.x-best.x,b.y-best.y));
        let chained=0;
        for(const e of near){
          if(chained>=p.chain) break;
          dealDamage(e, Math.round(p.dmg*0.65));
          chained++;
        }
      }
      return;
    }
    // default hit
    let best=null, bestD=999;
    for(const e of state.enemies){
      const d=Math.hypot(e.x-p.x,e.y-p.y);
      if(d<bestD){ bestD=d; best=e; }
    }
    if(best && bestD<28) dealDamage(best,p.dmg);
  }

  // ============================================================
  // UPDATE LOOP
  // ============================================================
  let last = performance.now();

  function update(dt){
    if(state.paused) return;
    dt *= state.speed;

    // spawns
    if(state.inWave && state.spawnQueue){
      for(const s of state.spawnQueue) s.t -= dt;
      while(state.spawnQueue.length && state.spawnQueue[0].t <= 0){
        const s = state.spawnQueue.shift();
        spawnEnemy(s.kind, s.tier, s.hp, s.spd, s.bounty, s.shield||0, s.boss||false, s.pathData);
      }
      state.spawnQueue.sort((a,b)=>a.t-b.t);

      if(state.spawnQueue.length===0 && state.enemies.length===0){
        state.spawnQueue=null;
        onWaveEnded();
      }
    }

    // next wave timer (after wave 1)
    if(!state.inWave && state.wave>0 && state.nextWaveTimer>0){
      state.nextWaveTimer -= dt;
      if(state.nextWaveTimer<=0){
        const m=currentMap();
        if(state.wave >= m.waves){
          const next=state.mapIndex+1;
          if(next>=MAPS.length) victory();
          else beginMap(next);
        }else{
          startWave();
        }
      }
    }

    // move enemies
    for(const e of state.enemies){
      e.dist += e.spd*dt;
      const p = posOnPath(e.pathData, e.dist);
      e.x=p.x; e.y=p.y; e.ang=p.ang;

      if(e.dist >= e.pathData.total){
        e.dead=true;
        state.lives = Math.max(0, state.lives - (e.boss?3:1));
        if(state.lives<=0) defeat();
      }
    }
    state.enemies = state.enemies.filter(e=>!e.dead);

    // turrets fire
    for(const t of state.turrets){
      t.cdLeft -= dt;
      if(t.cdLeft>0) continue;

      const type = TURRET_TYPES.find(x=>x.id===t.typeId);
      const st = turretStats(t.typeId, t.lvl);

      let target=null, bestScore=-1;
      for(const e of state.enemies){
        const d=Math.hypot(e.x-t.x,e.y-t.y);
        if(d>st.rng) continue;
        const progress=e.dist/e.pathData.total;
        const hpLeft=(e.shield>0?e.shield:0)+e.hp;
        const score=progress*2.0 + (1/(1+hpLeft))*0.6;
        if(score>bestScore){ bestScore=score; target=e; }
      }
      if(!target) continue;

      t.rot = Math.atan2(target.y-t.y, target.x-t.x);

      if(type.id==="splash") fireProjectile("shell", t, target, st.dmg, {splash:68});
      else if(type.id==="tesla") fireProjectile("pulse", t, target, st.dmg, {chain:2, chainRange:120});
      else if(type.id==="rail") fireProjectile("laser", t, target, st.dmg, {pierce:2, lineWidth:16});
      else if(type.id==="sniper") fireProjectile("laser", t, target, st.dmg, {pierce:0});
      else fireProjectile(type.proj, t, target, st.dmg, {});

      t.cdLeft = st.cd;
    }

    // projectiles
    for(const p of state.projectiles){
      p.t += dt;
      if(p.kind==="laser"){
        p.life -= dt;
        if(p.life<=0) p.dead=true;
        continue;
      }
      const vx=p.tx-p.x, vy=p.ty-p.y;
      const dist=Math.hypot(vx,vy);
      if(dist<1){
        impact(p);
        p.dead=true;
      }else{
        const step=Math.min(dist, p.spd*dt);
        p.x += vx/dist*step;
        p.y += vy/dist*step;
      }
    }
    state.projectiles = state.projectiles.filter(p=>!p.dead);

    syncUI();
  }

  // ============================================================
  // RENDER (more ‚Äúwar UI‚Äù look; still uses your sprites)
  // ============================================================
  function draw(){
    ctx.clearRect(0,0,viewW,viewH);

    // letterbox bars (if any)
    ctx.save();
    ctx.fillStyle="#00000066";
    const drawW=BASE_W*scale, drawH=BASE_H*scale;
    if(offY>0){ ctx.fillRect(0,0,viewW,offY); ctx.fillRect(0,offY+drawH,viewW,viewH-(offY+drawH)); }
    if(offX>0){ ctx.fillRect(0,0,offX,viewH); ctx.fillRect(offX+drawW,0,viewW-(offX+drawW),viewH); }
    ctx.restore();

    ctx.save();
    ctx.translate(offX,offY);
    ctx.scale(scale,scale);

    // subtle ground grid (less neon, more ‚Äútactical‚Äù)
    ctx.globalAlpha=0.12;
    ctx.strokeStyle="#ffffff22";
    ctx.lineWidth=1;
    for(let x=0;x<=BASE_W;x+=60){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,BASE_H); ctx.stroke(); }
    for(let y=0;y<=BASE_H;y+=60){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(BASE_W,y); ctx.stroke(); }
    ctx.globalAlpha=1;

    drawPath(currentMap().path);

    // ranges
    if(state.showRange){
      for(const t of state.turrets){
        const st=turretStats(t.typeId,t.lvl);
        const sel=(t.id===state.selectedTurretId);
        ctx.globalAlpha=sel?0.20:0.10;
        ctx.fillStyle=sel?"#53e6ff":"#53e6ff";
        ctx.beginPath(); ctx.arc(t.x,t.y,st.rng,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    // turrets
    for(const t of state.turrets) drawTurret(t);

    // enemies
    for(const e of state.enemies) drawEnemy(e);

    // projectiles
    for(const p of state.projectiles) drawProjectile(p);

    // selection ring
    const sel = state.turrets.find(t=>t.id===state.selectedTurretId);
    if(sel){
      ctx.strokeStyle="#53e6ff";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(sel.x,sel.y,36,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha=0.4;
      ctx.strokeStyle="#ffffff";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(sel.x,sel.y,40,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha=1;
    }

    // build ghost
    if(state.buildPick && state.mouseWorld && inWorld(state.mouseWorld.x,state.mouseWorld.y)){
      ctx.globalAlpha = canPlaceHere(state.mouseWorld.x,state.mouseWorld.y) ? 0.85 : 0.45;
      drawTurret({typeId:state.buildPick,lvl:1,x:state.mouseWorld.x,y:state.mouseWorld.y,rot:0});
      ctx.globalAlpha=1;
    }

    ctx.restore();
  }

  function drawPath(path){
    ctx.save();
    ctx.lineCap="round";
    ctx.lineJoin="round";

    // dirt/track base
    ctx.strokeStyle="#00000055";
    ctx.lineWidth=84;
    ctx.beginPath();
    ctx.moveTo(path[0].x,path[0].y);
    for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
    ctx.stroke();

    // subtle highlight
    ctx.strokeStyle="#53e6ff33";
    ctx.lineWidth=14;
    ctx.beginPath();
    ctx.moveTo(path[0].x,path[0].y);
    for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
    ctx.stroke();

    // start/end markers
    ctx.shadowBlur=18;
    ctx.shadowColor="#59ff7a";
    ctx.fillStyle="#59ff7a";
    ctx.beginPath(); ctx.arc(path[0].x,path[0].y,14,0,Math.PI*2); ctx.fill();

    const end=path[path.length-1];
    ctx.shadowColor="#ff4d4d";
    ctx.fillStyle="#ff4d4d";
    ctx.beginPath(); ctx.arc(end.x,end.y,14,0,Math.PI*2); ctx.fill();

    ctx.restore();
  }

  function drawTurret(t){
    const im = (SPR.turrets[t.typeId] && SPR.turrets[t.typeId][t.lvl]) || null;
    ctx.save();
    ctx.translate(t.x,t.y);
    ctx.rotate(t.rot||0);
    if(im){
      const s=0.62;
      ctx.drawImage(im, -im.width*s/2, -im.height*s/2, im.width*s, im.height*s);
    }else{
      ctx.fillStyle="#53e6ff";
      ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawEnemy(e){
    const im = (SPR.enemies[e.kind] && SPR.enemies[e.kind][e.tier]) || null;
    ctx.save();
    ctx.translate(e.x,e.y);
    ctx.rotate(e.ang + Math.PI/2);
    if(im){
      const s=e.boss?0.68:0.55;
      ctx.drawImage(im, -im.width*s/2, -im.height*s/2, im.width*s, im.height*s);
    }else{
      ctx.fillStyle="#ff4d4d";
      ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // hp/shield bar
    const base=enemyBase(e.kind);
    const maxHp=base.hp;
    const hpPct=Math.max(0,Math.min(1,e.hp/maxHp));
    const shieldPct=e.shield?Math.max(0,Math.min(1,e.shield/(base.shield||e.shield))):0;

    const w=e.boss?64:46, h=6;
    const x=e.x-w/2, y=e.y-(e.boss?46:36);

    ctx.save();
    ctx.globalAlpha=0.9;
    ctx.fillStyle="#00000088";
    ctx.fillRect(x,y,w,h);
    if(e.shield>0){
      ctx.fillStyle="#53e6ff";
      ctx.fillRect(x,y,w*shieldPct,h);
    }else{
      ctx.fillStyle="#f2c14f";
      ctx.fillRect(x,y,w*hpPct,h);
    }
    ctx.restore();
  }

  function drawProjectile(p){
    if(p.kind==="laser"){
      ctx.save();
      ctx.globalAlpha=0.9;
      ctx.strokeStyle="#ff4d4d";
      ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.tx,p.ty); ctx.stroke();
      ctx.globalAlpha=0.35;
      ctx.strokeStyle="#ffffff";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.tx,p.ty); ctx.stroke();
      ctx.restore();
      return;
    }
    const im = SPR.proj[p.kind] || null;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(Math.atan2(p.ty-p.y,p.tx-p.x));
    if(im){
      const s=0.7;
      ctx.drawImage(im, -im.width*s/2, -im.height*s/2, im.width*s, im.height*s);
    }else{
      ctx.fillStyle="#fff";
      ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // ============================================================
  // INPUT
  // ============================================================
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('mousemove', (e)=>{ state.mouseWorld = screenToWorld(e.clientX,e.clientY); });

  canvas.addEventListener('mousedown', (e)=>{
    const w = screenToWorld(e.clientX,e.clientY);
    if(!inWorld(w.x,w.y)) return;

    if(e.button===2){
      state.buildPick=null;
      rebuildBuildBar();
      toast("Build canceled.");
      return;
    }

    // select turret
    let hit=null;
    for(const t of state.turrets){
      if(Math.hypot(w.x-t.x,w.y-t.y) < 34){ hit=t; break; }
    }
    if(hit){
      state.selectedTurretId = hit.id;
      syncUI();
      return;
    }

    // place
    if(state.buildPick){
      placeTurret(state.buildPick, w.x, w.y);
      return;
    }

    state.selectedTurretId=null;
    syncUI();
  });

  // ============================================================
  // BUTTONS
  // ============================================================
  ui.btnPause.addEventListener('click', ()=>{ state.paused=!state.paused; syncUI(); });
  ui.btnRange.addEventListener('click', ()=>{ state.showRange=!state.showRange; syncUI(); });

  ui.btnStartWave.addEventListener('click', ()=> startWave());
  ui.btnSkip.addEventListener('click', ()=>{
    if(!state.allowSkip || state.inWave) return;
    state.nextWaveTimer = 0.01;
    state.allowSkip = false;
    toast("Timer skipped.");
    syncUI();
  });

  function setSpeed(n){ state.speed=n; syncUI(); }
  ui.btnSpd1.addEventListener('click', ()=>setSpeed(1));
  ui.btnSpd2.addEventListener('click', ()=>setSpeed(2));
  ui.btnSpd3.addEventListener('click', ()=>setSpeed(3));
  ui.btnSpd4.addEventListener('click', ()=>setSpeed(4));

  // safer restart hold
  let holdRAF=null, holdStart=0;
  function startHold(){
    holdStart=performance.now();
    holdRAF=requestAnimationFrame(function tick(now){
      const left = Math.max(0, 1200-(now-holdStart));
      ui.btnRestart.textContent = `HOLD RESTART (${(left/1000).toFixed(1)}s)`;
      if(now-holdStart >= 1200){
        cancelAnimationFrame(holdRAF); holdRAF=null;
        ui.btnRestart.textContent="RESTARTING‚Ä¶";
        resetCampaign();
        ui.btnRestart.textContent="HOLD RESTART (1.2s)";
        return;
      }
      holdRAF=requestAnimationFrame(tick);
    });
  }
  function stopHold(){
    if(holdRAF){ cancelAnimationFrame(holdRAF); holdRAF=null; }
    ui.btnRestart.textContent="HOLD RESTART (1.2s)";
  }
  ui.btnRestart.addEventListener('mousedown', startHold);
  window.addEventListener('mouseup', stopHold);

  // ============================================================
  // MAIN LOOP
  // ============================================================
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ============================================================
  // INIT
  // ============================================================
  (async function init(){
    resize();
    rebuildBuildBar();
    syncUI();
    await loadAssets();
    resetCampaign();
    requestAnimationFrame(loop);
  })();
})();
</script>
</body>
</html>
