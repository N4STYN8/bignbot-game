<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bignbot TD (Neon)</title>
  <style>
    :root{
      --bg0:#050611;
      --bg1:#070a18;
      --panel:#0b1026cc;
      --panel2:#0a0f24cc;
      --text:#eaf1ff;
      --muted:#a9b7ff;
      --cyan:#28f0ff;
      --mag:#ff3bd4;
      --lime:#70ff6b;
      --yel:#ffe66d;
      --red:#ff5f77;
      --line:rgba(255,255,255,0.12);
      --glow: 0 0 14px rgba(40,240,255,0.35), 0 0 34px rgba(255,59,212,0.18);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 420px at 50% 0%, rgba(255,59,212,0.18), transparent 60%),
        radial-gradient(900px 520px at 15% 80%, rgba(40,240,255,0.12), transparent 60%),
        radial-gradient(900px 520px at 85% 70%, rgba(112,255,107,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      display:grid; place-items:center;
      overflow-x:hidden;
    }
    .wrap{
      width:min(1220px, 96vw);
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:12px;
      align-items:start;
      position:relative;
    }
    /* subtle scanlines */
    .wrap::after{
      content:"";
      pointer-events:none;
      position:absolute; inset:-20px;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px
      );
      mix-blend-mode: overlay;
      opacity:0.35;
      border-radius:18px;
    }
    canvas{
      width:100%; height:auto;
      background:
        radial-gradient(900px 500px at 50% 30%, rgba(40,240,255,0.08), transparent 60%),
        linear-gradient(180deg, #060a16 0%, #050712 100%);
      border:1px solid rgba(255,255,255,0.16);
      border-radius:18px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.55), var(--glow);
      cursor:crosshair;
      position:relative;
      z-index:1;
    }
    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid rgba(255,255,255,0.16);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45), var(--glow);
      position:sticky; top:10px;
      z-index:1;
    }
    .title{
      font-weight:900; font-size:18px; letter-spacing:0.4px;
      text-shadow: 0 0 14px rgba(40,240,255,0.25), 0 0 24px rgba(255,59,212,0.20);
    }
    .muted{color:var(--muted); font-size:13px; line-height:1.35;}
    .row{display:flex; justify-content:space-between; gap:10px; margin:8px 0;}
    .big{font-size:18px; font-weight:900;}
    .grid{display:grid; gap:8px;}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
    button, select{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:var(--text);
      font-weight:800;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      outline:none;
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    button:hover, select:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(40,240,255,0.55);
      box-shadow: 0 0 14px rgba(40,240,255,0.18), 0 0 18px rgba(255,59,212,0.10);
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:0.45; cursor:not-allowed; }
    .seg{display:flex; gap:8px;}
    .seg button{ width:auto; flex:1; padding:9px 10px; }
    .pill{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      border-radius:16px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding: 2px 8px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.30);
      font-size: 12px;
    }
    .ok{color:var(--lime)}
    .bad{color:var(--red)}
    .warn{color:var(--yel)}
    .hint{margin-top:10px}
    .hr{height:1px; background:rgba(255,255,255,0.12); margin:12px 0;}
    .small{font-size:12px}
    .selected{
      border-color: rgba(255,59,212,0.85) !important;
      box-shadow: 0 0 0 2px rgba(255,59,212,0.18) inset, 0 0 18px rgba(40,240,255,0.14);
    }
    .danger{
      border-color: rgba(255,95,119,0.65) !important;
      box-shadow: 0 0 0 2px rgba(255,95,119,0.14) inset, 0 0 18px rgba(255,95,119,0.16);
    }
    .holdbar{
      height:8px; border-radius:999px;
      background: rgba(255,255,255,0.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.12);
    }
    .holdbar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(255,95,119,0.9), rgba(255,59,212,0.9), rgba(40,240,255,0.9));
      box-shadow: 0 0 16px rgba(255,59,212,0.25);
      transition: width 0.05s linear;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="860" height="540"></canvas>

    <div class="panel">
      <div class="title">Bignbot TD <span class="kbd">NEON</span></div>
      <div class="muted">Click to place turrets (not on path). Click a turret to upgrade or sell.</div>

      <div class="row"><div class="muted">Cash</div><div id="cash" class="big"></div></div>
      <div class="row"><div class="muted">Lives</div><div id="lives" class="big"></div></div>
      <div class="row"><div class="muted">Map</div><div id="mapName" class="big"></div></div>
      <div class="row"><div class="muted">Wave</div><div id="wave" class="big"></div></div>

      <div class="pill">
        <div class="muted">Game speed</div>
        <div class="seg">
          <button id="s1">1×</button>
          <button id="s2">2×</button>
          <button id="s3">3×</button>
          <button id="s4">4×</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="grid">
        <select id="mapSelect"></select>

        <div class="grid2">
          <button id="startWave">Start wave</button>
          <button id="pause">Pause</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="muted small">Turrets</div>
      <div class="grid" id="turretButtons"></div>

      <div class="hr"></div>

      <div class="muted small">Selected turret</div>
      <div id="selectedBox" class="pill">
        <div class="muted">None</div>
        <div class="kbd">Click a turret</div>
      </div>

      <div class="grid2" style="margin-top:8px">
        <button id="upgradeBtn" disabled>Upgrade</button>
        <button id="sellBtn" disabled>Sell</button>
      </div>

      <div id="msg" class="muted hint"></div>

      <div class="hr"></div>

      <!-- Safer restart: bottom + hold-to-confirm -->
      <div class="muted small">Safety</div>
      <button id="restartHold" class="danger">HOLD TO RESTART (1.2s)</button>
      <div class="holdbar"><div id="holdFill"></div></div>

      <div class="muted hint">
        Tips:
        <ul>
          <li><span class="kbd">R</span> toggles range preview.</li>
          <li>Sniper hits hard. Splash clears swarms.</li>
          <li>Bosses appear every 5 waves.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // UI
  const elCash = document.getElementById("cash");
  const elLives = document.getElementById("lives");
  const elWave = document.getElementById("wave");
  const elMapName = document.getElementById("mapName");
  const elMapSelect = document.getElementById("mapSelect");
  const elMsg = document.getElementById("msg");

  const btnStartWave = document.getElementById("startWave");
  const btnPause = document.getElementById("pause");

  const btnS1 = document.getElementById("s1");
  const btnS2 = document.getElementById("s2");
  const btnS3 = document.getElementById("s3");
  const btnS4 = document.getElementById("s4");

  const turretButtonsWrap = document.getElementById("turretButtons");
  const selectedBox = document.getElementById("selectedBox");
  const upgradeBtn = document.getElementById("upgradeBtn");
  const sellBtn = document.getElementById("sellBtn");

  const restartHoldBtn = document.getElementById("restartHold");
  const holdFill = document.getElementById("holdFill");

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  function setMsg(html, tone="") {
    elMsg.innerHTML = html ? `<div class="${tone}">${html}</div>` : "";
  }

  function linePointDistance(px,py, ax,ay, bx,by) {
    const vx = bx-ax, vy = by-ay;
    const wx = px-ax, wy = py-ay;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px-ax, py-ay);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px-bx, py-by);
    const t = c1 / c2;
    const projx = ax + t*vx, projy = ay + t*vy;
    return Math.hypot(px-projx, py-projy);
  }

  function getMousePos(evt) {
    const r = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - r.left) * (canvas.width / r.width),
      y: (evt.clientY - r.top) * (canvas.height / r.height),
    };
  }

  // Content
  const PATH_WIDTH = 50;

  // Maps (paths only). Waves are generated to 25.
  const MAPS = [
    {
      key: "training",
      name: "Training Grounds",
      path: [
        {x: 46, y: 270},
        {x: 210, y: 270},
        {x: 210, y: 130},
        {x: 440, y: 130},
        {x: 440, y: 410},
        {x: 680, y: 410},
        {x: 680, y: 230},
        {x: 820, y: 230},
      ],
      startingCash: 170,
      startingLives: 22,
    },
    {
      key: "crossroads",
      name: "Crossroads",
      path: [
        {x: 46, y: 100},
        {x: 270, y: 100},
        {x: 270, y: 270},
        {x: 140, y: 270},
        {x: 140, y: 440},
        {x: 540, y: 440},
        {x: 540, y: 210},
        {x: 800, y: 210},
      ],
      startingCash: 175,
      startingLives: 20,
    },
    {
      key: "spiral",
      name: "Spiral Run",
      path: [
        {x: 46, y: 440},
        {x: 780, y: 440},
        {x: 780, y: 120},
        {x: 150, y: 120},
        {x: 150, y: 360},
        {x: 650, y: 360},
        {x: 650, y: 190},
        {x: 280, y: 190},
        {x: 280, y: 290},
        {x: 820, y: 290},
      ],
      startingCash: 185,
      startingLives: 18,
    }
  ];

  // Turrets (better art + neon colors)
  const TURRET_TYPES = {
    basic: { name:"Basic", desc:"Balanced.", cost:60, range:145, damage:14, cooldown:0.52, projSpeed:460, pierce:1, splash:0, color:"#28f0ff" },
    rapid: { name:"Rapid", desc:"Fast shots.", cost:90, range:120, damage:7,  cooldown:0.16, projSpeed:560, pierce:1, splash:0, color:"#70ff6b" },
    sniper:{ name:"Sniper",desc:"Long range.", cost:135,range:260, damage:52, cooldown:1.25, projSpeed:780, pierce:1, splash:0, color:"#ff3bd4" },
    splash:{ name:"Splash",desc:"AOE mortar.", cost:120,range:165, damage:20, cooldown:0.82, projSpeed:380, pierce:1, splash:58, color:"#ffe66d" },
  };

  // State
  let nextId = 1;
  const state = {
    mapIdx: 0,
    path: MAPS[0].path,
    waves: [],
    inWave: false,
    waveIdx: 0,
    spawnTimer: 0,
    spawned: 0,
    waveGap: 0.42,

    enemies: [],
    turrets: [],
    projectiles: [],
    particles: [],
    muzzleFlashes: [],

    cash: 0,
    lives: 0,
    paused: false,
    gameOver: false,
    victory: false,
    showRanges: true,
    speed: 1,

    selectedTurretType: "basic",
    selectedTurretId: null,

    // restart hold
    holdActive: false,
    holdT: 0,
    holdNeed: 1.2,
  };

  // Waves: generate 25 per map (harder + bosses every 5)
  function generateWaves(mapKey) {
    // mapKey can slightly bias difficulty
    const bias = mapKey === "training" ? 0.95 : (mapKey === "crossroads" ? 1.0 : 1.06);
    const waves = [];
    for (let i=1;i<=25;i++){
      const isBoss = (i % 5 === 0);
      const tier = i;

      // base scaling
      const countBase = Math.round(10 + tier*1.2);
      const hpBase = 42 + tier*10;
      const speedBase = 55 + tier*1.2;

      // special flavors
      const armored = (tier >= 8 && (tier % 3 === 2));
      const fast = (tier >= 6 && (tier % 4 === 1));
      const swarm = (tier >= 10 && (tier % 4 === 3));

      let count = countBase;
      let hp = hpBase;
      let speed = speedBase;

      if (swarm) { count = Math.round(count*1.6); hp = Math.round(hp*0.72); speed = Math.round(speed*1.05); }
      if (fast)  { speed = Math.round(speed*1.28); hp = Math.round(hp*0.88); }
      if (armored){ hp = Math.round(hp*1.25); }

      if (isBoss) {
        count = 1;
        hp = Math.round((hpBase * 8.5) * bias);
        speed = Math.round((speedBase * 0.68));
      } else {
        hp = Math.round(hp * bias);
      }

      const reward = isBoss ? (80 + tier*6) : (11 + Math.floor(tier/2));

      waves.push({
        count,
        hp,
        speed,
        reward,
        boss: isBoss,
        armored: isBoss ? true : armored,
        fast: isBoss ? false : fast,
      });
    }
    return waves;
  }

  // Placement helpers
  function pointOnPath(px, py) {
    const path = state.path;
    for (let i=0; i<path.length-1; i++){
      const a = path[i], b = path[i+1];
      const d = linePointDistance(px,py,a.x,a.y,b.x,b.y);
      if (d <= PATH_WIDTH/2) return true;
    }
    return false;
  }
  function withinBounds(px, py) {
    return px >= 12 && px <= W-12 && py >= 12 && py <= H-12;
  }
  function turretAt(px, py) {
    for (const t of state.turrets){
      if (dist(px,py,t.x,t.y) <= t.r + 8) return t;
    }
    return null;
  }

  // Entities
  function makeEnemy(waveSpec) {
    const baseR = waveSpec.boss ? 18 : (waveSpec.fast ? 9 : 12);
    return {
      id: nextId++,
      x: state.path[0].x,
      y: state.path[0].y,
      r: baseR,
      hp: waveSpec.hp,
      maxHp: waveSpec.hp,
      speed: waveSpec.fast ? waveSpec.speed*1.15 : waveSpec.speed,
      reward: waveSpec.reward,
      armored: !!waveSpec.armored,
      boss: !!waveSpec.boss,
      pathIdx: 0,
      alive: true
    };
  }

  function makeTurret(x, y, typeKey) {
    const def = TURRET_TYPES[typeKey];
    const t = {
      id: nextId++,
      type: typeKey,
      x, y,
      r: 16,
      angle: 0,
      cooldown: 0,
      level: 1,
      baseRange: def.range,
      baseDamage: def.damage,
      baseCooldown: def.cooldown,
      baseProjSpeed: def.projSpeed,
      splash: def.splash,
      pierce: def.pierce,
      range: def.range,
      damage: def.damage,
      fireCd: def.cooldown,
      projSpeed: def.projSpeed,
      value: def.cost,
    };
    applyUpgrade(t);
    return t;
  }

  function makeProjectile(x,y, vx,vy, dmg, splash, pierce, color) {
    return { x,y,vx,vy, dmg,splash,pierce,color, alive:true, hitIds:new Set(), life:2.8 };
  }

  function addParticle(x,y, vx,vy, life, color="rgba(255,255,255,0.9)") {
    state.particles.push({x,y,vx,vy,life,maxLife:life,color});
  }

  // Upgrades
  function upgradeCost(t){
    const base = TURRET_TYPES[t.type].cost;
    return Math.round(base * (t.level === 1 ? 0.75 : 1.10));
  }
  function applyUpgrade(t){
    const lvl = t.level;
    const dmgMult = 1 + 0.50*(lvl-1);
    const rangeMult = 1 + 0.12*(lvl-1);
    const cdMult = Math.pow(0.86, (lvl-1)); // faster per level

    t.damage = t.baseDamage * dmgMult;
    t.range  = t.baseRange  * rangeMult;
    t.fireCd = t.baseCooldown * cdMult;
    t.projSpeed = t.baseProjSpeed;
  }
  function upgradeSelectedTurret(){
    const t = state.turrets.find(tt => tt.id === state.selectedTurretId);
    if (!t) return;
    if (t.level >= 3) { setMsg("Already max level.", "warn"); return; }
    const cost = upgradeCost(t);
    if (state.cash < cost) { setMsg("Not enough cash to upgrade.", "bad"); return; }
    state.cash -= cost;
    t.level++;
    t.value += cost;
    applyUpgrade(t);
    setMsg(`Upgraded <b>${TURRET_TYPES[t.type].name}</b> to Lv ${t.level}.`, "ok");
    syncSelectedUI(); syncUI();
  }
  function sellSelectedTurret(){
    const idx = state.turrets.findIndex(tt => tt.id === state.selectedTurretId);
    if (idx === -1) return;
    const t = state.turrets[idx];
    const refund = Math.round(t.value * 0.70);
    state.cash += refund;
    state.turrets.splice(idx,1);
    state.selectedTurretId = null;
    setMsg(`Sold turret for $${refund}.`, "ok");
    syncSelectedUI(); syncUI();
  }

  // Waves / map
  function currentMap(){ return MAPS[state.mapIdx]; }

  function startWave(){
    if (state.gameOver || state.victory || state.inWave) return;
    if (state.waveIdx >= state.waves.length) return;

    state.inWave = true;
    state.spawnTimer = 0;
    state.spawned = 0;

    // pacing tighter as waves increase
    state.waveGap = clamp(0.60 - state.waveIdx*0.014, 0.18, 0.60);
    setMsg(`Wave <b>${state.waveIdx+1}</b> started.`, "ok");
    syncUI();
  }

  function resetMap(){
    const map = currentMap();
    state.path = map.path;
    state.waves = generateWaves(map.key);

    state.cash = map.startingCash;
    state.lives = map.startingLives;
    state.waveIdx = 0;
    state.inWave = false;
    state.spawnTimer = 0;
    state.spawned = 0;

    state.enemies = [];
    state.turrets = [];
    state.projectiles = [];
    state.particles = [];
    state.muzzleFlashes = [];
    state.gameOver = false;
    state.victory = false;
    state.paused = false;

    state.selectedTurretId = null;

    // reset hold
    state.holdActive = false;
    state.holdT = 0;
    holdFill.style.width = "0%";

    setMsg("Place turrets, then start Wave 1.", "");
    syncSelectedUI(); syncUI();
  }

  function setMap(idx){
    state.mapIdx = idx;
    resetMap();
  }

  // UI build
  function buildMapSelect(){
    elMapSelect.innerHTML = "";
    MAPS.forEach((m,i)=>{
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = m.name;
      elMapSelect.appendChild(opt);
    });
    elMapSelect.value = String(state.mapIdx);
  }

  function buildTurretButtons(){
    turretButtonsWrap.innerHTML = "";
    Object.entries(TURRET_TYPES).forEach(([key,def])=>{
      const btn = document.createElement("button");
      btn.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center">
          <div style="text-align:left">
            <div style="font-weight:900">${def.name} <span class="muted">(${def.desc})</span></div>
            <div class="muted small">DMG ${def.damage} • RNG ${def.range} • CD ${def.cooldown.toFixed(2)}${def.splash?` • AOE ${def.splash}`:""}</div>
          </div>
          <div class="kbd">$${def.cost}</div>
        </div>`;
      btn.addEventListener("click", ()=>{
        state.selectedTurretType = key;
        highlightTurretType();
        setMsg(`Selected turret: <b>${def.name}</b>. Click map to place.`, "");
      });
      turretButtonsWrap.appendChild(btn);
    });
    highlightTurretType();
  }

  function highlightTurretType(){
    const keys = Object.keys(TURRET_TYPES);
    [...turretButtonsWrap.children].forEach((b,i)=>{
      b.classList.toggle("selected", keys[i] === state.selectedTurretType);
    });
  }

  function syncSelectedUI(){
    const t = state.turrets.find(tt => tt.id === state.selectedTurretId);
    if (!t){
      selectedBox.innerHTML = `<div class="muted">None</div><div class="kbd">Click a turret</div>`;
      upgradeBtn.disabled = true;
      sellBtn.disabled = true;
      return;
    }
    const def = TURRET_TYPES[t.type];
    const cost = t.level >= 3 ? "MAX" : `$${upgradeCost(t)}`;
    selectedBox.innerHTML = `
      <div style="text-align:left">
        <div style="font-weight:900">${def.name} <span class="muted">Lv ${t.level}/3</span></div>
        <div class="muted small">DMG ${t.damage.toFixed(1)} • RNG ${Math.round(t.range)} • CD ${t.fireCd.toFixed(2)}${t.splash?` • AOE ${t.splash}`:""}</div>
      </div>
      <div class="kbd">Upg: ${cost}</div>`;
    upgradeBtn.disabled = (t.level >= 3) || state.gameOver || state.victory;
    sellBtn.disabled = state.gameOver || state.victory;
  }

  function syncUI(){
    elCash.textContent = `$${state.cash}`;
    elLives.textContent = `${state.lives}`;
    const map = currentMap();
    elMapName.textContent = map.name;
    elWave.textContent = `${Math.min(state.waveIdx + (state.inWave?1:0), state.waves.length)} / ${state.waves.length}`;

    btnStartWave.disabled = state.inWave || state.gameOver || state.victory;
    btnPause.textContent = state.paused ? "Resume" : "Pause";

    // speed highlight
    [btnS1,btnS2,btnS3,btnS4].forEach(b=>b.classList.remove("selected"));
    ({1:btnS1,2:btnS2,3:btnS3,4:btnS4}[state.speed]).classList.add("selected");
  }

  // Input
  canvas.addEventListener("click", (evt)=>{
    if (state.gameOver || state.victory) return;
    const {x,y} = getMousePos(evt);
    if (!withinBounds(x,y)) return;

    const tHit = turretAt(x,y);
    if (tHit){
      state.selectedTurretId = tHit.id;
      setMsg(`Selected <b>${TURRET_TYPES[tHit.type].name}</b> (Lv ${tHit.level}).`, "");
      syncSelectedUI();
      return;
    }

    if (pointOnPath(x,y)) { setMsg("Can't place on the path.", "bad"); return; }

    for (const t of state.turrets){
      if (dist(x,y,t.x,t.y) < (t.r + 18)) { setMsg("Too close to another turret.", "bad"); return; }
    }

    const def = TURRET_TYPES[state.selectedTurretType];
    if (state.cash < def.cost) { setMsg("Not enough cash.", "bad"); return; }

    state.cash -= def.cost;
    const t = makeTurret(x,y,state.selectedTurretType);
    state.turrets.push(t);
    setMsg(`Placed <b>${def.name}</b>.`, "ok");
    syncUI();
  });

  window.addEventListener("keydown",(e)=>{
    if (e.key.toLowerCase() === "r"){
      state.showRanges = !state.showRanges;
      setMsg(`Range preview: <b>${state.showRanges ? "ON" : "OFF"}</b>.`, "");
    }
  });

  btnStartWave.addEventListener("click", startWave);
  btnPause.addEventListener("click", ()=>{ state.paused = !state.paused; syncUI(); });
  upgradeBtn.addEventListener("click", upgradeSelectedTurret);
  sellBtn.addEventListener("click", sellSelectedTurret);

  function setSpeed(n){ state.speed = n; syncUI(); }
  btnS1.addEventListener("click",()=>setSpeed(1));
  btnS2.addEventListener("click",()=>setSpeed(2));
  btnS3.addEventListener("click",()=>setSpeed(3));
  btnS4.addEventListener("click",()=>setSpeed(4));

  elMapSelect.addEventListener("change", ()=>setMap(Number(elMapSelect.value)));

  // Restart (hold to confirm)
  function setHoldUI(){
    const pct = clamp(state.holdT / state.holdNeed, 0, 1);
    holdFill.style.width = `${Math.round(pct*100)}%`;
  }
  function cancelHold(){
    state.holdActive = false;
    state.holdT = 0;
    setHoldUI();
  }
  restartHoldBtn.addEventListener("mousedown", ()=>{
    if (state.holdActive) return;
    state.holdActive = true;
    state.holdT = 0;
    setMsg("Holding… keep holding to restart.", "warn");
  });
  window.addEventListener("mouseup", ()=>{
    if (!state.holdActive) return;
    cancelHold();
    setMsg("", "");
  });
  restartHoldBtn.addEventListener("mouseleave", ()=>{ if (state.holdActive) cancelHold(); });

  // Combat / targeting
  function findBestTarget(t){
    let best=null, bestScore=-Infinity;
    for (const e of state.enemies){
      const d = dist(t.x,t.y,e.x,e.y);
      if (d > t.range) continue;
      const score = e.pathIdx*10000 - d;
      if (score > bestScore){ bestScore=score; best=e; }
    }
    return best;
  }

  function spawnLogic(dt){
    if (!state.inWave) return;
    const wave = state.waves[state.waveIdx];
    state.spawnTimer -= dt;

    if (state.spawned < wave.count && state.spawnTimer <= 0){
      state.enemies.push(makeEnemy(wave));
      state.spawned++;
      state.spawnTimer = state.waveGap;
    }

    if (state.spawned >= wave.count && state.enemies.length === 0){
      state.inWave = false;
      state.waveIdx++;

      if (state.waveIdx >= state.waves.length){
        state.victory = true;
        setMsg(`<b class="ok">VICTORY!</b> You cleared <b>${currentMap().name}</b>.`, "");
      } else {
        setMsg(`Wave cleared. Ready for <b>Wave ${state.waveIdx+1}</b>.`, "ok");
      }
      syncUI();
    }
  }

  function moveEnemies(dt){
    const path = state.path;
    for (const e of state.enemies){
      const a = path[e.pathIdx];
      const b = path[e.pathIdx+1];
      if (!b){
        state.lives -= 1;
        e.alive = false;
        continue;
      }
      const dx = b.x - e.x, dy = b.y - e.y;
      const d = Math.hypot(dx,dy);
      if (d < 0.001){ e.pathIdx++; continue; }

      const step = e.speed * dt;
      const nx = dx/d, ny = dy/d;
      if (step >= d){ e.x=b.x; e.y=b.y; e.pathIdx++; }
      else { e.x += nx*step; e.y += ny*step; }
    }

    state.enemies = state.enemies.filter(e => e.alive && e.hp > 0);

    if (state.lives <= 0 && !state.gameOver){
      state.lives = 0;
      state.gameOver = true;
      state.inWave = false;
      setMsg(`<b class="bad">GAME OVER.</b> Hold restart to try again.`, "");
      syncUI(); syncSelectedUI();
    }
  }

  function turretLogic(dt){
    for (const t of state.turrets){
      t.cooldown -= dt;
      if (t.cooldown > 0) continue;

      const target = findBestTarget(t);
      if (!target) continue;

      const dx = target.x - t.x, dy = target.y - t.y;
      t.angle = Math.atan2(dy, dx);

      const d = Math.hypot(dx,dy) || 1;
      const vx = (dx/d) * t.projSpeed;
      const vy = (dy/d) * t.projSpeed;

      const color = TURRET_TYPES[t.type].color;
      state.projectiles.push(makeProjectile(
        t.x + Math.cos(t.angle)*20,
        t.y + Math.sin(t.angle)*20,
        vx, vy,
        t.damage,
        t.splash,
        t.pierce,
        color
      ));

      state.muzzleFlashes.push({x:t.x, y:t.y, a:t.angle, life:0.09, color});
      t.cooldown = t.fireCd;
    }
  }

  function projectileLogic(dt){
    for (const p of state.projectiles){
      p.life -= dt;
      if (p.life <= 0){ p.alive=false; continue; }

      const px0=p.x, py0=p.y;
      p.x += p.vx*dt;
      p.y += p.vy*dt;

      if (p.x < -60 || p.x > W+60 || p.y < -60 || p.y > H+60){ p.alive=false; continue; }

      for (const e of state.enemies){
        if (p.pierce <= 0) break;
        if (p.hitIds.has(e.id)) continue;

        if (dist(p.x,p.y,e.x,e.y) <= e.r + 5){
          p.hitIds.add(e.id);

          const dmg = e.armored ? p.dmg*0.78 : p.dmg;
          e.hp -= dmg;

          // hit sparks
          for (let i=0;i<7;i++){
            const ang = Math.random()*Math.PI*2;
            const sp = 90 + Math.random()*160;
            addParticle(e.x, e.y, Math.cos(ang)*sp, Math.sin(ang)*sp, 0.18+Math.random()*0.18, "rgba(40,240,255,0.95)");
          }

          if (p.splash > 0){
            for (const e2 of state.enemies){
              if (e2.id === e.id) continue;
              if (dist(e.x,e.y,e2.x,e2.y) <= p.splash){
                const dmg2 = e2.armored ? p.dmg*0.62 : p.dmg*0.84;
                e2.hp -= dmg2;
              }
            }
            // splash ring
            for (let i=0;i<16;i++){
              const ang = (i/16)*Math.PI*2;
              addParticle(e.x + Math.cos(ang)*6, e.y + Math.sin(ang)*6, Math.cos(ang)*160, Math.sin(ang)*160, 0.22, "rgba(255,59,212,0.85)");
            }
          }

          if (e.hp <= 0){
            state.cash += e.reward + (e.boss ? 50 : 0);
            // death burst
            for (let i=0;i<18;i++){
              const ang = Math.random()*Math.PI*2;
              const sp = 100 + Math.random()*220;
              addParticle(e.x, e.y, Math.cos(ang)*sp, Math.sin(ang)*sp, 0.28+Math.random()*0.22, "rgba(255,230,109,0.95)");
            }
          }

          p.pierce -= 1;
          if (p.pierce <= 0) p.alive = false;
        }
      }

      // trail
      if (Math.random() < 0.85){
        addParticle(px0, py0, (p.vx*-0.03), (p.vy*-0.03), 0.10, "rgba(255,255,255,0.75)");
      }
    }

    state.projectiles = state.projectiles.filter(p => p.alive);
  }

  function particlesLogic(dt){
    for (const q of state.particles){
      q.life -= dt;
      if (q.life <= 0) continue;
      q.x += q.vx*dt;
      q.y += q.vy*dt;
      q.vx *= (1 - 2.4*dt);
      q.vy *= (1 - 2.4*dt);
    }
    state.particles = state.particles.filter(q => q.life > 0);

    for (const f of state.muzzleFlashes) f.life -= dt;
    state.muzzleFlashes = state.muzzleFlashes.filter(f => f.life > 0);
  }

  // Draw (neon grid + path + better turrets)
  function drawNeonGrid(t){
    const step = 42;
    ctx.globalAlpha = 0.12;
    ctx.lineWidth = 1;

    // animated offset
    const ox = (t*18) % step;
    const oy = (t*12) % step;

    for (let x=-step; x<=W+step; x+=step){
      ctx.strokeStyle = "rgba(40,240,255,0.35)";
      ctx.beginPath(); ctx.moveTo(x+ox,0); ctx.lineTo(x+ox,H); ctx.stroke();
    }
    for (let y=-step; y<=H+step; y+=step){
      ctx.strokeStyle = "rgba(255,59,212,0.25)";
      ctx.beginPath(); ctx.moveTo(0,y+oy); ctx.lineTo(W,y+oy); ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawPath(){
    const path = state.path;

    // fat base
    ctx.lineCap="round"; ctx.lineJoin="round";
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.lineWidth=PATH_WIDTH;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    // neon edge
    ctx.strokeStyle="rgba(40,240,255,0.22)";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    // start/end
    const s=path[0], e=path[path.length-1];
    ctx.fillStyle="rgba(112,255,107,0.14)";
    ctx.beginPath(); ctx.arc(s.x,s.y,16,0,Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(255,95,119,0.18)";
    ctx.beginPath(); ctx.arc(e.x,e.y,18,0,Math.PI*2); ctx.fill();
  }

  function drawParticles(){
    for (const q of state.particles){
      const a = clamp(q.life/q.maxLife,0,1);
      ctx.globalAlpha = a;
      ctx.fillStyle = q.color;
      ctx.beginPath();
      ctx.arc(q.x,q.y, 1.7, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawProjectile(){
    for (const p of state.projectiles){
      ctx.strokeStyle = p.color;
      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(p.x,p.y, 2.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawEnemies(){
    for (const e of state.enemies){
      // body glow
      const glow = e.boss ? 0.35 : 0.22;
      ctx.shadowColor = e.boss ? "rgba(255,230,109,0.85)" : "rgba(40,240,255,0.75)";
      ctx.shadowBlur = e.boss ? 18 : 12;

      ctx.fillStyle = e.boss ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.86)";
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();

      ctx.shadowBlur = 0;

      if (e.armored){
        ctx.strokeStyle="rgba(255,230,109,0.80)";
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+2,0,Math.PI*2); ctx.stroke();
      }

      // HP bar
      const w = e.boss ? 60 : 38;
      const h = 7;
      const x = e.x - w/2;
      const y = e.y - e.r - 16;
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(x,y,w,h);

      const hpPct = clamp(e.hp/e.maxHp,0,1);
      ctx.fillStyle = e.boss ? "rgba(255,59,212,0.85)" : "rgba(40,240,255,0.70)";
      ctx.fillRect(x,y,w*hpPct,h);
      ctx.globalAlpha = 1;
    }
  }

  // Better turret art per type (silhouettes)
  function drawTurretShape(t){
    const def = TURRET_TYPES[t.type];
    const c = def.color;

    // range preview
    if (state.showRanges){
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = c;
      ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // base plate (hex)
    const baseR = t.r+2;
    ctx.save();
    ctx.translate(t.x,t.y);

    // glow outline
    ctx.shadowColor = c;
    ctx.shadowBlur = 14;

    // base
    ctx.fillStyle = "rgba(10,14,34,0.92)";
    ctx.strokeStyle = c;
    ctx.lineWidth = (state.selectedTurretId===t.id) ? 4.5 : 3;

    ctx.beginPath();
    for (let i=0;i<6;i++){
      const a = (Math.PI*2)*(i/6) + Math.PI/6;
      const x = Math.cos(a)*baseR;
      const y = Math.sin(a)*baseR;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 0.92;
    ctx.stroke();
    ctx.globalAlpha = 1;

    // inner ring
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.stroke();

    // turret body + barrels (rotate)
    ctx.rotate(t.angle);

    function bodyRect(w,h,fillA){
      ctx.fillStyle = `rgba(255,255,255,${fillA})`;
      ctx.fillRect(-w/2,-h/2,w,h);
    }

    // platform
    ctx.fillStyle = `rgba(0,0,0,0.35)`;
    ctx.fillRect(-10,-6,20,12);

    // type silhouettes
    if (t.type === "basic"){
      bodyRect(16,10,0.14);
      // single barrel
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.fillRect(4,-2,18,4);
      ctx.fillStyle = c;
      ctx.fillRect(14,-1,10,2);
    } else if (t.type === "rapid"){
      bodyRect(18,12,0.12);
      // twin barrels
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillRect(4,-5,16,3);
      ctx.fillRect(4, 2,16,3);
      ctx.fillStyle = c;
      ctx.fillRect(14,-4,8,1.5);
      ctx.fillRect(14, 3,8,1.5);
    } else if (t.type === "sniper"){
      bodyRect(18,10,0.10);
      // long barrel
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.fillRect(4,-1.8,28,3.6);
      // scope
      ctx.fillStyle = c;
      ctx.fillRect(-2,-7,10,3);
      ctx.strokeStyle = "rgba(255,255,255,0.45)";
      ctx.lineWidth = 1;
      ctx.strokeRect(-2,-7,10,3);
    } else if (t.type === "splash"){
      bodyRect(18,12,0.10);
      // mortar bowl
      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(10,0,9, -Math.PI/2, Math.PI/2);
      ctx.stroke();
      ctx.fillStyle = c;
      ctx.fillRect(6,-1,10,2);
    }

    // level pips
    ctx.rotate(-t.angle);
    ctx.shadowBlur = 10;
    for (let i=0;i<t.level;i++){
      ctx.fillStyle = c;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(-12 + i*12, 20, 3.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawTurrets(){
    for (const t of state.turrets) drawTurretShape(t);

    // muzzle flashes
    for (const f of state.muzzleFlashes){
      const a = clamp(f.life/0.09,0,1);
      ctx.globalAlpha = a;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(f.x + Math.cos(f.a)*24, f.y + Math.sin(f.a)*24, 5.5, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawHUD(){
    ctx.fillStyle = "rgba(255,255,255,0.80)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const status = state.gameOver ? "GAME OVER" : (state.victory ? "VICTORY" : (state.paused ? "PAUSED" : "RUN"));
    ctx.fillText(`Wave ${Math.min(state.waveIdx + (state.inWave?1:0), state.waves.length)}/${state.waves.length} | Enemies ${state.enemies.length} | Speed ${state.speed}x | ${status}`, 14, 18);
  }

  function draw(t){
    ctx.clearRect(0,0,W,H);
    drawNeonGrid(t);
    drawPath();
    drawParticles();
    drawProjectile();
    drawEnemies();
    drawTurrets();
    drawHUD();
  }

  // Loop
  let last = performance.now();
  let timeAcc = 0;

  function update(dt){
    if (state.paused || state.gameOver || state.victory) {
      // still update restart hold UI
    } else {
      spawnLogic(dt);
      moveEnemies(dt);
      turretLogic(dt);
      projectileLogic(dt);
      particlesLogic(dt);
      syncUI();
    }

    // Restart hold tick
    if (state.holdActive){
      state.holdT += dt;
      setHoldUI();
      if (state.holdT >= state.holdNeed){
        state.holdActive = false;
        state.holdT = 0;
        setHoldUI();
        resetMap();
      }
    }
  }

  function loop(now){
    const rawDt = Math.min(0.033, (now-last)/1000);
    last = now;
    const dt = rawDt * state.speed;

    timeAcc += rawDt;
    update(dt);
    draw(timeAcc);
    requestAnimationFrame(loop);
  }

  // Buttons + init
  function buildAll(){
    buildMapSelect();
    buildTurretButtons();
    elMapSelect.value = String(state.mapIdx);
  }

  function init(){
    buildAll();

    // defaults
    resetMap();
    syncSelectedUI();
    syncUI();
    setMsg("Neon mode online. Place turrets and start Wave 1.", "ok");

    requestAnimationFrame(loop);
  }

  // other controls
  btnStartWave.addEventListener("click", startWave);

  upgradeBtn.addEventListener("click", upgradeSelectedTurret);
  sellBtn.addEventListener("click", sellSelectedTurret);

  function setSpeed(n){ state.speed = n; syncUI(); }
  btnS1.addEventListener("click",()=>setSpeed(1));
  btnS2.addEventListener("click",()=>setSpeed(2));
  btnS3.addEventListener("click",()=>setSpeed(3));
  btnS4.addEventListener("click",()=>setSpeed(4));

  init();
})();
</script>
</body>
</html>
