<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Bignbot TD — Campaign</title>
  <style>
    :root{
      --bg0:#070812;
      --bg1:#0b1030;
      --bg2:#060915;

      --txt:#eef3ff;
      --mut:#9fb0ff;

      --c1:#1df2ff;   /* cyan */
      --c2:#ff4fd8;   /* magenta */
      --c3:#78ff7a;   /* lime */
      --c4:#ffe66d;   /* yellow */
      --c5:#ff5c74;   /* red */

      --line: rgba(255,255,255,.14);
      --glass: rgba(12,16,42,.72);
      --glass2: rgba(12,16,42,.52);

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --glow: 0 0 18px rgba(29,242,255,.14), 0 0 38px rgba(255,79,216,.10);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 520px at 50% 0%, rgba(255,79,216,.18), transparent 60%),
        radial-gradient(900px 520px at 20% 70%, rgba(29,242,255,.12), transparent 60%),
        radial-gradient(900px 520px at 85% 78%, rgba(120,255,122,.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden; /* IMPORTANT: page never scrolls */
    }

    /* ---------- FRAME THAT ALWAYS FITS ---------- */
    .frame{
      height: 100vh;
      width: 100vw;
      padding: clamp(10px, 1.4vw, 16px);
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    .app{
      width: min(1400px, 100%);
      height: 100%;
      border-radius: 22px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      box-shadow: var(--shadow), var(--glow);
      overflow:hidden;

      display:grid;
      grid-template-columns: 340px 1fr 340px;
      grid-template-rows: auto 1fr auto;
      grid-template-areas:
        "leftTop topBar rightTop"
        "leftMid play rightMid"
        "shop    shop  sideBot";
      gap: 12px;
      padding: 12px;
      min-height: 0; /* allow children to size without forcing overflow */
    }

    /* Panels */
    .panel{
      border-radius: 18px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      backdrop-filter: blur(10px);
      box-shadow: var(--glow);
      padding: 12px;
      min-height: 0;
    }

    .title{
      font-weight: 900;
      letter-spacing:.4px;
      display:flex;
      align-items:center;
      gap:10px;
      margin:0 0 10px 0;
    }
    .badge{
      font-size: 11px;
      padding: 3px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: var(--txt);
      font-weight: 800;
      white-space:nowrap;
    }

    .kv{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin-top:8px;
      font-size: 13px;
      color: var(--mut);
    }
    .kv b{
      color: var(--txt);
      font-size: 18px;
      font-weight: 900;
    }

    /* ---------- GRID AREAS ---------- */
    .leftTop{ grid-area:leftTop; }
    .topBar{ grid-area:topBar; display:flex; gap:12px; align-items:stretch; }
    .rightTop{ grid-area:rightTop; }

    .leftMid{ grid-area:leftMid; }
    .play{ grid-area:play; position:relative; min-height: 0; }
    .rightMid{ grid-area:rightMid; }

    .shop{ grid-area:shop; }
    .sideBot{ grid-area:sideBot; }

    /* ---------- TOP BAR CONTENT ---------- */
    .topBar .panel{ flex:1; }
    .topBar .panel.compact{
      max-width: 420px;
    }

    /* Buttons */
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      transition: transform .06s ease, background .14s ease, border-color .14s ease, box-shadow .14s ease, opacity .14s ease;
      outline:none;
    }
    button:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(29,242,255,.55);
      box-shadow: 0 0 14px rgba(29,242,255,.16), 0 0 18px rgba(255,79,216,.10);
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .on{ border-color: rgba(255,79,216,.85) !important; box-shadow: 0 0 0 2px rgba(255,79,216,.14) inset; }
    .primary{
      border-color: rgba(29,242,255,.55);
      box-shadow: 0 0 0 2px rgba(29,242,255,.10) inset;
    }
    .danger{
      border-color: rgba(255,92,116,.55);
      box-shadow: 0 0 0 2px rgba(255,92,116,.12) inset;
    }

    .btnGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .seg{
      display:flex;
      gap:8px;
      margin-top:8px;
    }
    .seg button{ flex:1; }

    .msg{
      font-size: 13px;
      color: var(--mut);
      line-height:1.25;
      min-height: 34px;
      margin-top: 8px;
    }
    .ok{ color: var(--c3); }
    .bad{ color: var(--c5); }
    .warn{ color: var(--c4); }

    /* ---------- CANVAS ---------- */
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(900px 520px at 50% 30%, rgba(29,242,255,.08), transparent 60%),
        linear-gradient(180deg, #060a16 0%, #050712 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
    }
    .scanlines{
      pointer-events:none;
      position:absolute; inset:0;
      border-radius: 18px;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.02) 0px,
        rgba(255,255,255,.02) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 7px
      );
      opacity:.35;
      mix-blend-mode: overlay;
    }

    /* ---------- SHOP STRIP (inside frame, not page scroll) ---------- */
    .shop{
      display:flex;
      gap: 10px;
      overflow:hidden;
      min-height: 0;
    }
    .shop .panel{
      width: 100%;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .cards{
      display:flex;
      gap: 10px;
      overflow-x:auto;
      overflow-y:hidden;
      padding-bottom: 6px;
      scrollbar-color: rgba(255,255,255,.25) transparent;
    }
    .cards::-webkit-scrollbar{ height:10px; }
    .cards::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.22);
      border-radius:999px;
      border: 2px solid rgba(0,0,0,.2);
    }
    .card{
      min-width: 230px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding: 10px;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, background .14s ease, border-color .14s ease, box-shadow .14s ease, opacity .14s ease;
      position:relative;
    }
    .card:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(29,242,255,.55);
      box-shadow: 0 0 16px rgba(29,242,255,.14), 0 0 18px rgba(255,79,216,.10);
    }
    .card:active{ transform: translateY(1px); }
    .card.selected{
      border-color: rgba(255,79,216,.85);
      box-shadow: 0 0 0 2px rgba(255,79,216,.14) inset, 0 0 18px rgba(29,242,255,.10);
    }
    .card.locked{ opacity:.55; cursor:not-allowed; }
    .card h4{
      margin:0 0 6px 0;
      font-size: 14px;
      font-weight: 950;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      align-items:flex-start;
    }
    .chip{
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      white-space:nowrap;
    }
    .stat{
      font-size: 12px;
      color: var(--mut);
      line-height:1.25;
    }

    /* Selected panel bottom right */
    .sideBot .sub{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      padding: 10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04);
    }

    .holdbar{
      height: 9px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
      overflow:hidden;
      margin-top: 8px;
    }
    .holdbar > div{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(255,92,116,.9), rgba(255,79,216,.9), rgba(29,242,255,.9));
      transition: width .05s linear;
      box-shadow: 0 0 16px rgba(255,79,216,.22);
    }

    /* ---------- RESPONSIVE: stack on small screens ---------- */
    @media (max-width: 1100px){
      .app{
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto 1fr auto auto;
        grid-template-areas:
          "leftTop rightTop"
          "play play"
          "topBar topBar"
          "shop sideBot";
      }
      .topBar{ flex-wrap:wrap; }
    }

    @media (max-width: 740px){
      .app{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto auto;
        grid-template-areas:
          "leftTop"
          "rightTop"
          "play"
          "topBar"
          "shop"
          "sideBot";
      }
      .cards .card{ min-width: 200px; }
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="app">

      <div class="panel leftTop">
        <div class="title">Bignbot TD <span class="badge">CAMPAIGN</span></div>
        <div class="kv"><span>Map</span><b id="mapName">—</b></div>
        <div class="kv"><span>Wave</span><b id="waveText">—</b></div>
        <div class="msg" id="statusMsg"></div>
      </div>

      <div class="topBar">
        <div class="panel compact">
          <div class="kv"><span>Cash</span><b id="cash">$0</b></div>
          <div class="kv"><span>Lives</span><b id="lives">0</b></div>
          <div class="kv"><span>Next wave</span><b id="nextWave">—</b></div>
        </div>

        <div class="panel">
          <div class="title" style="margin-bottom:6px">Wave Control</div>
          <div class="btnGrid">
            <button id="startWaveBtn" class="primary">Start Wave 1</button>
            <button id="skipBtn" disabled>Start Next Now</button>
          </div>
          <div class="msg">
            Wave 1 is manual. After that: auto-start 30s after clear (or press <b>Start Next Now</b>).
          </div>
        </div>
      </div>

      <div class="panel rightTop">
        <div class="title">Controls</div>
        <div class="btnGrid">
          <button id="pauseBtn">Pause</button>
          <button id="rangeBtn">Range: ON</button>
        </div>

        <div style="margin-top:10px; font-size:12px; color:var(--mut); font-weight:900;">Speed</div>
        <div class="seg">
          <button id="s1" class="on">1×</button>
          <button id="s2">2×</button>
          <button id="s3">3×</button>
          <button id="s4">4×</button>
        </div>

        <div class="msg" id="hudLine"></div>
      </div>

      <div class="panel leftMid">
        <div class="title">Tips</div>
        <div class="stat">• Click a card below to select a turret.</div>
        <div class="stat">• Click the field to place (not on the path).</div>
        <div class="stat">• Click a turret to select it for upgrade/sell.</div>
        <div class="stat">• Cannon/Frost/Laser unlock as you progress.</div>
      </div>

      <div class="play">
        <canvas id="game"></canvas>
        <div class="scanlines"></div>
      </div>

      <div class="panel rightMid">
        <div class="title">Selected</div>
        <div class="sub" id="selectedBox">
          <div class="stat">None (click a turret)</div>
        </div>

        <div class="btnGrid" style="margin-top:10px">
          <button id="upgradeBtn" disabled class="primary">Upgrade</button>
          <button id="sellBtn" disabled>Sell</button>
        </div>

        <button id="restartHold" class="danger" style="width:100%; margin-top:10px">HOLD TO RESTART (1.2s)</button>
        <div class="holdbar"><div id="holdFill"></div></div>
      </div>

      <div class="shop">
        <div class="panel" style="width:100%">
          <div class="title" style="justify-content:space-between">
            <span>Build</span>
            <span class="badge">SHOP</span>
          </div>
          <div class="cards" id="buildCards"></div>
        </div>
      </div>

      <div class="panel sideBot">
        <div class="title">Log</div>
        <div class="msg" id="msg"></div>
        <div class="stat">Campaign auto-advances maps. Clear 25 waves to move on.</div>
      </div>

    </div>
  </div>

<script>
(() => {
  // ---------- Canvas logical size ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const LOGICAL_W = 980;
  const LOGICAL_H = 560;

  function resizeCanvas(){
    const r = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.round(r.width * dpr);
    canvas.height = Math.round(r.height * dpr);
    ctx.setTransform(canvas.width / LOGICAL_W, 0, 0, canvas.height / LOGICAL_H, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas, {passive:true});
  resizeCanvas();

  function getMouse(evt){
    const r = canvas.getBoundingClientRect();
    return { x: (evt.clientX - r.left) * (LOGICAL_W / r.width),
             y: (evt.clientY - r.top)  * (LOGICAL_H / r.height) };
  }

  // ---------- UI ----------
  const elMapName = document.getElementById("mapName");
  const elWaveText = document.getElementById("waveText");
  const elCash = document.getElementById("cash");
  const elLives = document.getElementById("lives");
  const elNextWave = document.getElementById("nextWave");
  const elHudLine = document.getElementById("hudLine");
  const elStatusMsg = document.getElementById("statusMsg");
  const elMsg = document.getElementById("msg");

  const buildCards = document.getElementById("buildCards");
  const selectedBox = document.getElementById("selectedBox");

  const startWaveBtn = document.getElementById("startWaveBtn");
  const skipBtn = document.getElementById("skipBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const rangeBtn = document.getElementById("rangeBtn");
  const upgradeBtn = document.getElementById("upgradeBtn");
  const sellBtn = document.getElementById("sellBtn");

  const s1 = document.getElementById("s1");
  const s2 = document.getElementById("s2");
  const s3 = document.getElementById("s3");
  const s4 = document.getElementById("s4");

  const restartHoldBtn = document.getElementById("restartHold");
  const holdFill = document.getElementById("holdFill");

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  function setMsg(html, tone=""){
    if(!html){ elMsg.innerHTML=""; return; }
    elMsg.innerHTML = `<span class="${tone}">${html}</span>`;
  }
  function setStatus(html, tone=""){
    if(!html){ elStatusMsg.innerHTML=""; return; }
    elStatusMsg.innerHTML = `<span class="${tone}">${html}</span>`;
  }

  // ---------- Campaign maps ----------
  const MAPS = [
    { key:"training", name:"Training Grounds",
      path:[{x:46,y:280},{x:210,y:280},{x:210,y:140},{x:460,y:140},{x:460,y:420},{x:700,y:420},{x:700,y:240},{x:920,y:240}],
      startingCash:170, startingLives:22
    },
    { key:"crossroads", name:"Crossroads",
      path:[{x:46,y:110},{x:280,y:110},{x:280,y:290},{x:140,y:290},{x:140,y:460},{x:560,y:460},{x:560,y:220},{x:920,y:220}],
      startingCash:180, startingLives:20
    },
    { key:"spiral", name:"Spiral Run",
      path:[{x:46,y:460},{x:880,y:460},{x:880,y:120},{x:160,y:120},{x:160,y:360},{x:740,y:360},{x:740,y:190},{x:320,y:190},{x:320,y:300},{x:920,y:300}],
      startingCash:190, startingLives:18
    }
  ];

  // ---------- Turrets ----------
  const TURRET_TYPES = {
    basic:  { name:"Basic",  desc:"Balanced.",     cost:60,  range:145, damage:14, cooldown:0.52, projSpeed:460, pierce:1, splash:0,  slow:0,    color:"#1df2ff", unlock: ()=>true },
    rapid:  { name:"Rapid",  desc:"Fast shots.",   cost:90,  range:120, damage:7,  cooldown:0.16, projSpeed:560, pierce:1, splash:0,  slow:0,    color:"#78ff7a", unlock: ()=>true },
    sniper: { name:"Sniper", desc:"Long range.",   cost:135, range:260, damage:52, cooldown:1.25, projSpeed:780, pierce:1, splash:0,  slow:0,    color:"#ff4fd8", unlock: ()=>true },
    splash: { name:"Splash", desc:"AOE mortar.",   cost:120, range:165, damage:20, cooldown:0.82, projSpeed:380, pierce:1, splash:58, slow:0,    color:"#ffe66d", unlock: ()=>true },

    cannon: { name:"Cannon", desc:"Piercing slug.", cost:160, range:175, damage:28, cooldown:0.70, projSpeed:520, pierce:3, splash:0,  slow:0,    color:"#a8b0ff",
              unlock:(st)=>st.mapIdx>=1 },
    frost:  { name:"Frost",  desc:"Slows enemies.", cost:145, range:155, damage:10, cooldown:0.28, projSpeed:520, pierce:1, splash:0,  slow:0.45, color:"#7fe8ff",
              unlock:(st)=>st.mapIdx>=2 },
    laser:  { name:"Laser",  desc:"Hitscan beam.",  cost:190, range:230, damage:18, cooldown:0.18, projSpeed:9999,pierce:1, splash:0,  slow:0,    color:"#ff63ff",
              unlock:(st)=>st.mapIdx>=2 && st.waveIdx>=9 }
  };

  function unlockTextFor(key){
    if(key==="cannon") return "Unlock: Map 2";
    if(key==="frost")  return "Unlock: Map 3";
    if(key==="laser")  return "Unlock: Map 3 Wave 10";
    return "";
  }

  // ---------- State ----------
  let nextId = 1;
  const PATH_WIDTH = 50;

  const state = {
    mapIdx:0,
    path: MAPS[0].path,
    waves: [],
    waveIdx:0,
    inWave:false,
    spawnTimer:0,
    spawned:0,
    waveGap:0.42,

    enemies:[],
    turrets:[],
    projectiles:[],
    particles:[],
    beams:[],
    flashes:[],

    cash:0,
    lives:0,

    paused:false,
    victory:false,
    gameOver:false,

    showRanges:true,
    speed:1,

    selectedTurretType:"basic",
    selectedTurretId:null,

    // Wave flow:
    // - Wave 1 manual
    // - After that auto with 30s timer, but can be skipped with button
    autoEnabled:false,
    autoDelay:30,
    autoTimer:30,

    holdActive:false,
    holdT:0,
    holdNeed:1.2
  };

  function currentMap(){ return MAPS[state.mapIdx]; }

  function generateWaves(mapKey){
    const bias = mapKey==="training"?0.95:(mapKey==="crossroads"?1.0:1.06);
    const waves=[];
    for(let i=1;i<=25;i++){
      const isBoss = (i%5===0);
      const tier=i;
      let count = Math.round(10 + tier*1.2);
      let hp = 42 + tier*10;
      let speed = 55 + tier*1.2;

      const armored = (tier>=8 && (tier%3===2));
      const fast = (tier>=6 && (tier%4===1));
      const swarm = (tier>=10 && (tier%4===3));

      if(swarm){ count=Math.round(count*1.6); hp=Math.round(hp*0.72); speed=Math.round(speed*1.05); }
      if(fast){ speed=Math.round(speed*1.28); hp=Math.round(hp*0.88); }
      if(armored){ hp=Math.round(hp*1.25); }

      if(isBoss){
        count=1;
        hp=Math.round((hp*8.5)*bias);
        speed=Math.round(speed*0.68);
      }else{
        hp=Math.round(hp*bias);
      }

      const reward = isBoss ? (80 + tier*6) : (11 + Math.floor(tier/2));
      waves.push({count,hp,speed,reward,boss:isBoss,armored:isBoss?true:armored,fast:isBoss?false:fast});
    }
    return waves;
  }

  // ---------- Geometry helpers ----------
  function linePointDistance(px,py, ax,ay, bx,by){
    const vx=bx-ax, vy=by-ay;
    const wx=px-ax, wy=py-ay;
    const c1=vx*wx + vy*wy;
    if(c1<=0) return Math.hypot(px-ax, py-ay);
    const c2=vx*vx + vy*vy;
    if(c2<=c1) return Math.hypot(px-bx, py-by);
    const t=c1/c2;
    const projx=ax + t*vx, projy=ay + t*vy;
    return Math.hypot(px-projx, py-projy);
  }
  function pointOnPath(px,py){
    const p=state.path;
    for(let i=0;i<p.length-1;i++){
      if(linePointDistance(px,py,p[i].x,p[i].y,p[i+1].x,p[i+1].y) <= PATH_WIDTH/2) return true;
    }
    return false;
  }
  function turretAt(px,py){
    for(const t of state.turrets){
      if(dist(px,py,t.x,t.y) <= t.r+10) return t;
    }
    return null;
  }

  // ---------- Entities ----------
  function makeEnemy(wave){
    const r = wave.boss ? 18 : (wave.fast ? 9 : 12);
    return {
      id: nextId++,
      x: state.path[0].x, y: state.path[0].y,
      r,
      hp: wave.hp, maxHp: wave.hp,
      speed: wave.fast ? wave.speed*1.15 : wave.speed,
      baseSpeed: wave.fast ? wave.speed*1.15 : wave.speed,
      slowMul: 1, slowT: 0,
      reward: wave.reward,
      armored: !!wave.armored,
      boss: !!wave.boss,
      pathIdx: 0,
      alive: true
    };
  }

  function applyUpgrade(t){
    const lvl=t.level;
    const dmgMult = 1 + 0.50*(lvl-1);
    const rangeMult= 1 + 0.12*(lvl-1);
    const cdMult = Math.pow(0.86,(lvl-1));

    t.damage = t.baseDamage * dmgMult;
    t.range  = t.baseRange  * rangeMult;
    t.fireCd = t.baseCooldown * cdMult;

    if(t.type==="laser") t.damage = t.baseDamage*(1+0.35*(lvl-1));
    if(t.type==="frost") t.slow = 0.45 + 0.10*(lvl-1);
    if(t.type==="cannon") t.pierce = 3 + (lvl-1);
  }

  function makeTurret(x,y,typeKey){
    const def=TURRET_TYPES[typeKey];
    const t={
      id: nextId++,
      type:typeKey,
      x,y,
      r:16,
      angle:0,
      cooldown:0,
      level:1,

      baseRange:def.range,
      baseDamage:def.damage,
      baseCooldown:def.cooldown,
      baseProjSpeed:def.projSpeed,

      splash:def.splash,
      pierce:def.pierce,
      slow:def.slow||0,

      range:def.range,
      damage:def.damage,
      fireCd:def.cooldown,
      projSpeed:def.projSpeed,

      value:def.cost
    };
    applyUpgrade(t);
    return t;
  }

  function upgradeCost(t){
    const base=TURRET_TYPES[t.type].cost;
    return Math.round(base * (t.level===1 ? 0.75 : 1.10));
  }

  function makeProjectile(x,y,vx,vy,dmg,splash,pierce,color,slow=0){
    return {x,y,vx,vy,dmg,splash,pierce,color,slow,alive:true,hitIds:new Set(),life:2.8};
  }

  function addParticle(x,y,vx,vy,life,color){
    state.particles.push({x,y,vx,vy,life,maxLife:life,color});
  }

  // ---------- UI Sync ----------
  function syncHUD(){
    elMapName.textContent = currentMap().name;

    const waveNow = Math.min(state.waveIdx + (state.inWave?1:0), state.waves.length);
    elWaveText.textContent = `${waveNow}/25`;

    elCash.textContent = `$${state.cash}`;
    elLives.textContent = `${state.lives}`;

    if(state.gameOver) elNextWave.textContent = "—";
    else if(state.victory) elNextWave.textContent = "DONE";
    else if(state.inWave) elNextWave.textContent = "IN WAVE";
    else if(!state.autoEnabled && state.waveIdx===0) elNextWave.textContent = "MANUAL";
    else elNextWave.textContent = `${Math.ceil(state.autoTimer)}s`;

    pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    rangeBtn.textContent = `Range: ${state.showRanges ? "ON" : "OFF"}`;

    // Start Wave 1 button only for wave 1 (each map)
    const canStartWave1 = (!state.inWave && !state.gameOver && !state.victory && state.waveIdx===0 && !state.autoEnabled);
    startWaveBtn.disabled = !canStartWave1;
    startWaveBtn.textContent = canStartWave1 ? "Start Wave 1" : "Wave 1 Started";

    // Skip timer: after wave 1 and between waves (auto-enabled)
    const canSkip = (!state.inWave && !state.gameOver && !state.victory && state.autoEnabled && state.waveIdx < state.waves.length);
    skipBtn.disabled = !canSkip;

    elHudLine.textContent =
      `MAP ${state.mapIdx+1}/${MAPS.length} | ENEMIES ${state.enemies.length} | SPEED ${state.speed}x | ` +
      (state.gameOver ? "GAME OVER" : (state.victory ? "VICTORY" : (state.paused ? "PAUSED" : "RUN")));
  }

  function syncSelectedUI(){
    const t = state.turrets.find(tt=>tt.id===state.selectedTurretId);
    if(!t){
      selectedBox.innerHTML = `<div class="stat">None (click a turret)</div>`;
      upgradeBtn.disabled = true;
      sellBtn.disabled = true;
      return;
    }
    const def=TURRET_TYPES[t.type];
    selectedBox.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
        <div>
          <div style="font-weight:950">${def.name} <span style="color:var(--mut);font-weight:800">Lv ${t.level}/3</span></div>
          <div class="stat">
            DMG ${t.damage.toFixed(1)} • RNG ${Math.round(t.range)} • CD ${t.fireCd.toFixed(2)}
            ${t.splash?` • AOE ${t.splash}`:""}
            ${t.slow?` • SLOW ${Math.round(t.slow*100)}%`:""}
            ${t.pierce>1?` • PIERCE ${t.pierce}`:""}
          </div>
        </div>
        <div class="badge">Upg: ${t.level>=3 ? "MAX" : `$${upgradeCost(t)}`}</div>
      </div>
    `;
    upgradeBtn.disabled = state.gameOver || state.victory || t.level>=3;
    sellBtn.disabled = state.gameOver || state.victory;
  }

  function buildShop(){
    buildCards.innerHTML="";
    for(const [key,def] of Object.entries(TURRET_TYPES)){
      const unlocked = def.unlock(state);
      const div=document.createElement("div");
      div.className = "card" + (state.selectedTurretType===key ? " selected" : "") + (!unlocked ? " locked" : "");
      div.innerHTML = `
        <h4><span>${def.name}</span><span class="chip">$${def.cost}</span></h4>
        <div class="stat">DMG ${def.damage} • RNG ${def.range} • CD ${def.cooldown.toFixed(2)}
          ${def.splash?` • AOE ${def.splash}`:""}${def.slow?` • SLOW ${Math.round((def.slow||0.45)*100)}%`:""}${def.pierce>1?` • PIERCE ${def.pierce}`:""}
        </div>
        <div class="stat">${def.desc}</div>
        ${unlocked ? "" : `<div class="stat" style="margin-top:8px"><span class="badge">${unlockTextFor(key)}</span></div>`}
      `;
      div.addEventListener("click",()=>{
        if(!unlocked){
          setMsg(`Locked: <b>${def.name}</b>. ${unlockTextFor(key)}.`, "warn");
          return;
        }
        state.selectedTurretType=key;
        buildShop();
        setMsg(`Selected <b>${def.name}</b>. Click the field to place.`, "");
      });
      buildCards.appendChild(div);
    }
    if(!TURRET_TYPES[state.selectedTurretType].unlock(state)){
      state.selectedTurretType="basic";
      buildShop();
    }
  }

  // ---------- Wave / Map flow ----------
  function startWave(){
    if(state.gameOver||state.victory||state.inWave) return;
    if(state.waveIdx>=state.waves.length) return;

    state.inWave=true;
    state.spawnTimer=0;
    state.spawned=0;
    state.waveGap=clamp(0.60 - state.waveIdx*0.014, 0.18, 0.60);

    setStatus(`Wave <b>${state.waveIdx+1}</b> started.`, "ok");
  }

  function advanceMap(){
    if(state.mapIdx < MAPS.length-1){
      const next = state.mapIdx+1;
      setMsg(`<span class="ok"><b>MAP CLEARED!</b></span> Loading <b>${MAPS[next].name}</b>…`, "");
      loadMap(next, true);
    } else {
      state.victory=true;
      setStatus(`<span class="ok"><b>CAMPAIGN VICTORY!</b></span>`, "");
      setMsg(`<span class="ok"><b>YOU WIN.</b></span> Hold restart to play again.`, "");
    }
  }

  function loadMap(idx, carry){
    state.mapIdx=idx;
    state.path=MAPS[idx].path;
    state.waves=generateWaves(MAPS[idx].key);

    state.waveIdx=0;
    state.inWave=false;
    state.spawnTimer=0;
    state.spawned=0;

    state.enemies=[];
    state.turrets=[];
    state.projectiles=[];
    state.particles=[];
    state.beams=[];
    state.flashes=[];

    state.paused=false;
    state.gameOver=false;
    state.victory=false;

    state.selectedTurretId=null;

    // Wave 1 manual EACH MAP, then auto after that
    state.autoEnabled=false;
    state.autoTimer=state.autoDelay;

    if(!carry){
      state.cash=MAPS[idx].startingCash;
      state.lives=MAPS[idx].startingLives;
    } else {
      state.cash += 80;
      state.lives = Math.min(state.lives + 2, 30);
    }

    buildShop();
    syncSelectedUI();
    syncHUD();
    setStatus(`Place turrets, then start <b>Wave 1</b>.`, "ok");
  }

  function resetCampaign(){
    loadMap(0, false);
  }

  // ---------- Combat logic ----------
  function spawnLogic(dt){
    if(!state.inWave) return;
    const wave = state.waves[state.waveIdx];

    state.spawnTimer -= dt;
    if(state.spawned < wave.count && state.spawnTimer <= 0){
      state.enemies.push(makeEnemy(wave));
      state.spawned++;
      state.spawnTimer = state.waveGap;
    }

    if(state.spawned >= wave.count && state.enemies.length === 0){
      state.inWave=false;
      state.waveIdx++;

      // enable auto after wave 1 completes
      if(state.waveIdx >= 1) state.autoEnabled=true;

      buildShop(); // unlock checks

      if(state.waveIdx >= state.waves.length){
        setStatus(`<span class="ok"><b>All 25 waves cleared!</b></span>`, "");
        advanceMap();
      } else {
        if(state.autoEnabled){
          state.autoTimer = state.autoDelay;
          setStatus(`Wave cleared. Next wave in <b>${state.autoDelay}s</b> (or press Start Next).`, "ok");
        } else {
          setStatus(`Wave cleared. Start when ready.`, "ok");
        }
      }
    }
  }

  function moveEnemies(dt){
    const path = state.path;
    for(const e of state.enemies){
      if(e.slowT>0){
        e.slowT -= dt;
        if(e.slowT<=0){ e.slowMul=1; e.slowT=0; }
      }
      const speed = e.baseSpeed * e.slowMul;

      const a = path[e.pathIdx];
      const b = path[e.pathIdx+1];
      if(!b){
        state.lives -= 1;
        e.alive = false;
        continue;
      }

      const dx=b.x-e.x, dy=b.y-e.y;
      const d=Math.hypot(dx,dy);
      if(d<0.001){ e.pathIdx++; continue; }
      const step=speed*dt;
      const nx=dx/d, ny=dy/d;
      if(step>=d){ e.x=b.x; e.y=b.y; e.pathIdx++; }
      else { e.x += nx*step; e.y += ny*step; }
    }
    state.enemies = state.enemies.filter(e=>e.alive && e.hp>0);

    if(state.lives<=0 && !state.gameOver){
      state.lives=0;
      state.gameOver=true;
      state.inWave=false;
      setStatus(`<span class="bad"><b>GAME OVER.</b></span>`, "");
      setMsg(`<span class="warn">Hold restart to retry.</span>`, "");
      syncSelectedUI();
    }
  }

  function findBestTarget(t){
    let best=null, bestScore=-Infinity;
    for(const e of state.enemies){
      const d=dist(t.x,t.y,e.x,e.y);
      if(d>t.range) continue;
      const score = e.pathIdx*10000 - d - (e.hp*0.01);
      if(score>bestScore){ bestScore=score; best=e; }
    }
    return best;
  }

  function turretLogic(dt){
    for(const t of state.turrets){
      t.cooldown -= dt;
      if(t.cooldown>0) continue;

      const target = findBestTarget(t);
      if(!target) continue;

      const dx=target.x-t.x, dy=target.y-t.y;
      t.angle = Math.atan2(dy,dx);

      const color = TURRET_TYPES[t.type].color;

      // Laser: hitscan
      if(t.type==="laser"){
        state.beams.push({x1:t.x,y1:t.y,x2:target.x,y2:target.y,life:0.08,color});
        const dmg = target.armored ? t.damage*0.85 : t.damage;
        target.hp -= dmg;

        for(let i=0;i<7;i++){
          const ang=Math.random()*Math.PI*2, sp=120+Math.random()*160;
          addParticle(target.x,target.y,Math.cos(ang)*sp,Math.sin(ang)*sp,0.18,"rgba(255,99,255,0.9)");
        }

        if(target.hp<=0){
          state.cash += target.reward + (target.boss ? 50 : 0);
        }
        t.cooldown = t.fireCd;
        continue;
      }

      const d=Math.hypot(dx,dy) || 1;
      const vx=(dx/d)*t.projSpeed, vy=(dy/d)*t.projSpeed;

      state.projectiles.push(makeProjectile(
        t.x + Math.cos(t.angle)*20,
        t.y + Math.sin(t.angle)*20,
        vx,vy,
        t.damage,
        t.splash,
        t.pierce,
        color,
        t.slow||0
      ));
      state.flashes.push({x:t.x,y:t.y,a:t.angle,life:0.09,color});
      t.cooldown = t.fireCd;
    }
  }

  function projectileLogic(dt){
    for(const p of state.projectiles){
      p.life -= dt;
      if(p.life<=0){ p.alive=false; continue; }

      p.x += p.vx*dt;
      p.y += p.vy*dt;

      if(p.x<-60||p.x>LOGICAL_W+60||p.y<-60||p.y>LOGICAL_H+60){ p.alive=false; continue; }

      for(const e of state.enemies){
        if(p.pierce<=0) break;
        if(p.hitIds.has(e.id)) continue;

        if(dist(p.x,p.y,e.x,e.y) <= e.r+5){
          p.hitIds.add(e.id);

          const dmg = e.armored ? p.dmg*0.78 : p.dmg;
          e.hp -= dmg;

          if(p.slow>0){
            e.slowMul = Math.min(e.slowMul, 1 - p.slow);
            e.slowT = Math.max(e.slowT, 1.6);
          }

          if(p.splash>0){
            for(const e2 of state.enemies){
              if(e2.id===e.id) continue;
              if(dist(e.x,e.y,e2.x,e2.y) <= p.splash){
                const dmg2 = e2.armored ? p.dmg*0.62 : p.dmg*0.84;
                e2.hp -= dmg2;
              }
            }
          }

          if(e.hp<=0){
            state.cash += e.reward + (e.boss ? 50 : 0);
          }

          p.pierce -= 1;
          if(p.pierce<=0) p.alive=false;
        }
      }
    }
    state.projectiles = state.projectiles.filter(p=>p.alive);
  }

  function particlesLogic(dt){
    for(const q of state.particles){
      q.life -= dt;
      if(q.life<=0) continue;
      q.x += q.vx*dt; q.y += q.vy*dt;
      q.vx *= (1-2.4*dt); q.vy *= (1-2.4*dt);
    }
    state.particles = state.particles.filter(q=>q.life>0);

    for(const b of state.beams) b.life -= dt;
    state.beams = state.beams.filter(b=>b.life>0);

    for(const f of state.flashes) f.life -= dt;
    state.flashes = state.flashes.filter(f=>f.life>0);
  }

  // Auto wave countdown (after wave 1)
  function autoWaveTick(dt){
    if(state.gameOver||state.victory) return;
    if(state.inWave) return;
    if(state.waveIdx>=state.waves.length) return;

    // wave 1 manual only
    if(!state.autoEnabled && state.waveIdx===0) return;

    state.autoTimer -= dt;
    if(state.autoTimer<=0){
      state.autoTimer=0;
      startWave();
    }
  }

  // ---------- Restart hold ----------
  function holdTick(dt){
    if(!state.holdActive) return;
    state.holdT += dt;
    const pct=clamp(state.holdT/state.holdNeed,0,1);
    holdFill.style.width = `${Math.round(pct*100)}%`;
    if(state.holdT>=state.holdNeed){
      state.holdActive=false;
      state.holdT=0;
      holdFill.style.width="0%";
      resetCampaign();
      setMsg(`<span class="ok"><b>Restarted.</b></span>`, "");
    }
  }
  function cancelHold(){
    state.holdActive=false;
    state.holdT=0;
    holdFill.style.width="0%";
  }

  // ---------- Drawing ----------
  const step=42;
  function drawGrid(t){
    const ox=(t*18)%step, oy=(t*12)%step;
    ctx.globalAlpha=0.10;
    ctx.lineWidth=1;
    for(let x=-step;x<=LOGICAL_W+step;x+=step){
      ctx.strokeStyle="rgba(29,242,255,0.30)";
      ctx.beginPath(); ctx.moveTo(x+ox,0); ctx.lineTo(x+ox,LOGICAL_H); ctx.stroke();
    }
    for(let y=-step;y<=LOGICAL_H+step;y+=step){
      ctx.strokeStyle="rgba(255,79,216,0.22)";
      ctx.beginPath(); ctx.moveTo(0,y+oy); ctx.lineTo(LOGICAL_W,y+oy); ctx.stroke();
    }
    ctx.globalAlpha=1;
  }

  function drawPath(){
    const p=state.path;
    ctx.lineCap="round"; ctx.lineJoin="round";

    // soft lane
    ctx.strokeStyle="rgba(255,255,255,0.08)";
    ctx.lineWidth=PATH_WIDTH;
    ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y);
    for(let i=1;i<p.length;i++) ctx.lineTo(p[i].x,p[i].y);
    ctx.stroke();

    // inner neon rails
    ctx.strokeStyle="rgba(29,242,255,0.18)";
    ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y);
    for(let i=1;i<p.length;i++) ctx.lineTo(p[i].x,p[i].y);
    ctx.stroke();
  }

  function drawBeams(){
    for(const b of state.beams){
      const a=clamp(b.life/0.08,0,1);
      ctx.globalAlpha=a;
      ctx.strokeStyle=b.color;
      ctx.lineWidth=3.2;
      ctx.beginPath(); ctx.moveTo(b.x1,b.y1); ctx.lineTo(b.x2,b.y2); ctx.stroke();

      ctx.strokeStyle="rgba(255,255,255,0.85)";
      ctx.lineWidth=1.1;
      ctx.beginPath(); ctx.moveTo(b.x1,b.y1); ctx.lineTo(b.x2,b.y2); ctx.stroke();
      ctx.globalAlpha=1;
    }
  }

  function drawProjectiles(){
    for(const p of state.projectiles){
      ctx.globalAlpha=0.85;
      ctx.strokeStyle=p.color;
      ctx.lineWidth=2.4;
      ctx.beginPath();
      ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
      ctx.lineTo(p.x,p.y);
      ctx.stroke();
      ctx.globalAlpha=1;

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.beginPath(); ctx.arc(p.x,p.y,2.4,0,Math.PI*2); ctx.fill();
    }
  }

  function drawEnemies(){
    for(const e of state.enemies){
      const slowGlow = (e.slowT>0) ? "rgba(127,232,255,0.9)" : "rgba(29,242,255,0.75)";
      ctx.shadowColor = e.boss ? "rgba(255,230,109,0.85)" : slowGlow;
      ctx.shadowBlur = e.boss ? 18 : 12;

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=0;

      if(e.armored){
        ctx.strokeStyle="rgba(255,230,109,0.78)";
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+2,0,Math.PI*2); ctx.stroke();
      }
      if(e.slowT>0){
        ctx.strokeStyle="rgba(127,232,255,0.75)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+6,0,Math.PI*2); ctx.stroke();
      }

      // HP bar
      const w=e.boss?60:38, h=7;
      const x=e.x-w/2, y=e.y-e.r-16;
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.fillRect(x,y,w,h);
      const hpPct=clamp(e.hp/e.maxHp,0,1);
      ctx.fillStyle=e.boss?"rgba(255,79,216,0.85)":"rgba(29,242,255,0.70)";
      ctx.fillRect(x,y,w*hpPct,h);
      ctx.globalAlpha=1;
    }
  }

  // Turret visuals that change by upgrade level (simple but distinct)
  function drawTurret(t){
    const c = TURRET_TYPES[t.type].color;

    if(state.showRanges){
      ctx.globalAlpha=0.06;
      ctx.fillStyle=c;
      ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }

    ctx.save();
    ctx.translate(t.x,t.y);

    // base
    const baseR = t.r+2 + (t.level-1)*1.2;
    ctx.shadowColor=c; ctx.shadowBlur=14;
    ctx.fillStyle="rgba(10,14,34,0.92)";
    ctx.strokeStyle=c;
    ctx.lineWidth=(state.selectedTurretId===t.id)?4.2:2.8;

    // hex platform
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const a=(Math.PI*2)*(i/6)+Math.PI/6;
      const x=Math.cos(a)*baseR, y=Math.sin(a)*baseR;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.shadowBlur=0;

    // core ring
    ctx.strokeStyle="rgba(255,255,255,0.20)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,9+(t.level-1)*1.2,0,Math.PI*2); ctx.stroke();

    // rotate to aim
    ctx.rotate(t.angle);

    // body & barrel patterns by type/level
    const bodyRect=(w,h,a)=>{ ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.fillRect(-w/2,-h/2,w,h); };

    if(t.type==="basic"){
      bodyRect(18+t.level*2, 12, 0.12);
      ctx.fillStyle="rgba(255,255,255,0.80)";
      for(let i=0;i<t.level;i++){
        const oy=(i-(t.level-1)/2)*3.6;
        ctx.fillRect(4, oy-1.4, 18+t.level*3, 2.8);
      }
    } else if(t.type==="rapid"){
      bodyRect(20+t.level*2, 14, 0.10);
      const lines = (t.level===1)?2:(t.level===2?3:4);
      ctx.fillStyle="rgba(255,255,255,0.78)";
      for(let i=0;i<lines;i++){
        const oy=(i-(lines-1)/2)*3.0;
        ctx.fillRect(4, oy-1.1, 16+t.level*2, 2.2);
      }
      if(t.level>=2){
        ctx.fillStyle=c;
        ctx.fillRect(-8,-11,8,4);
        ctx.fillRect(-8, 7,8,4);
      }
    } else if(t.type==="sniper"){
      bodyRect(20+t.level*2, 12, 0.08);
      ctx.fillStyle="rgba(255,255,255,0.82)";
      ctx.fillRect(4,-1.6, 32+t.level*8, 3.2);
      if(t.level>=2){
        ctx.fillStyle=c; ctx.fillRect(0,-10,12,4);
      }
      if(t.level>=3){
        ctx.fillStyle="rgba(255,255,255,0.12)";
        ctx.fillRect(-12,-14,8,28);
      }
    } else if(t.type==="splash"){
      bodyRect(20+t.level*2, 14, 0.08);
      ctx.strokeStyle="rgba(255,255,255,0.70)";
      ctx.lineWidth=2.2;
      ctx.beginPath(); ctx.arc(10,0,10+t.level*2, -Math.PI/2, Math.PI/2); ctx.stroke();
    } else if(t.type==="cannon"){
      bodyRect(20+t.level*2, 14, 0.10);
      ctx.fillStyle="rgba(255,255,255,0.86)";
      ctx.fillRect(4,-3, 26+t.level*6, 6);
      ctx.fillStyle=c;
      ctx.fillRect(22+t.level*5,-4,10,8);
    } else if(t.type==="frost"){
      bodyRect(20+t.level*2, 14, 0.08);
      ctx.fillStyle=c;
      ctx.beginPath();
      ctx.moveTo(6,0);
      ctx.lineTo(24+t.level*4,-8);
      ctx.lineTo(24+t.level*4, 8);
      ctx.closePath();
      ctx.fill();
      if(t.level>=2){
        ctx.strokeStyle="rgba(255,255,255,0.30)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke();
      }
    } else if(t.type==="laser"){
      bodyRect(20+t.level*2, 14, 0.06);
      ctx.fillStyle=c;
      ctx.beginPath(); ctx.arc(10,0,7+t.level*1.6,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,0.55)";
      ctx.lineWidth=2;
      const prongs=2+(t.level-1);
      for(let i=0;i<prongs;i++){
        const oy=(i-(prongs-1)/2)*5;
        ctx.beginPath(); ctx.moveTo(16,oy); ctx.lineTo(34+t.level*4,oy); ctx.stroke();
      }
    }

    ctx.restore();
  }

  function drawFlashes(){
    for(const f of state.flashes){
      const a=clamp(f.life/0.09,0,1);
      ctx.globalAlpha=a;
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.beginPath(); ctx.arc(f.x+Math.cos(f.a)*24, f.y+Math.sin(f.a)*24, 5.5, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }
  }

  function draw(t){
    ctx.clearRect(0,0,LOGICAL_W,LOGICAL_H);
    drawGrid(t);
    drawPath();
    drawBeams();
    drawProjectiles();
    drawEnemies();
    for(const tur of state.turrets) drawTurret(tur);
    drawFlashes();
  }

  // ---------- Input ----------
  canvas.addEventListener("click",(evt)=>{
    if(state.gameOver||state.victory) return;
    const {x,y}=getMouse(evt);

    const hit=turretAt(x,y);
    if(hit){
      state.selectedTurretId=hit.id;
      setMsg(`Selected <b>${TURRET_TYPES[hit.type].name}</b>.`, "");
      syncSelectedUI();
      return;
    }

    if(pointOnPath(x,y)){ setMsg(`<span class="bad"><b>Can't place on path.</b></span>`, ""); return; }
    for(const t of state.turrets){
      if(dist(x,y,t.x,t.y) < (t.r+18)){
        setMsg(`<span class="bad"><b>Too close</b></span> to another turret.`, "");
        return;
      }
    }

    const def=TURRET_TYPES[state.selectedTurretType];
    if(!def.unlock(state)){
      setMsg(`Locked: ${unlockTextFor(state.selectedTurretType)}.`, "warn");
      return;
    }
    if(state.cash < def.cost){
      setMsg(`<span class="bad"><b>Not enough cash.</b></span>`, "");
      return;
    }

    state.cash -= def.cost;
    state.turrets.push(makeTurret(x,y,state.selectedTurretType));
    setMsg(`Placed <b>${def.name}</b>.`, "ok");
    syncHUD();
  });

  // ---------- Buttons ----------
  startWaveBtn.addEventListener("click", ()=>{
    if(state.waveIdx===0 && !state.autoEnabled && !state.inWave) startWave();
  });

  // Skip timer after first wave: start immediately when between waves
  skipBtn.addEventListener("click", ()=>{
    if(state.inWave || state.gameOver || state.victory) return;
    if(!state.autoEnabled) return;
    state.autoTimer = 0;
    startWave();
  });

  pauseBtn.addEventListener("click", ()=>{ state.paused=!state.paused; syncHUD(); });
  rangeBtn.addEventListener("click", ()=>{ state.showRanges=!state.showRanges; syncHUD(); });

  function setSpeed(n){
    state.speed=n;
    [s1,s2,s3,s4].forEach(b=>b.classList.remove("on"));
    ({1:s1,2:s2,3:s3,4:s4}[n]).classList.add("on");
    syncHUD();
  }
  s1.addEventListener("click",()=>setSpeed(1));
  s2.addEventListener("click",()=>setSpeed(2));
  s3.addEventListener("click",()=>setSpeed(3));
  s4.addEventListener("click",()=>setSpeed(4));

  upgradeBtn.addEventListener("click", ()=>{
    const t=state.turrets.find(tt=>tt.id===state.selectedTurretId);
    if(!t) return;
    if(t.level>=3){ setMsg("Max level.", "warn"); return; }
    const cost=upgradeCost(t);
    if(state.cash < cost){ setMsg(`<span class="bad"><b>Not enough cash.</b></span>`, ""); return; }
    state.cash -= cost;
    t.level++; t.value += cost;
    applyUpgrade(t);
    setMsg(`Upgraded <b>${TURRET_TYPES[t.type].name}</b> to Lv ${t.level}.`, "ok");
    syncSelectedUI(); syncHUD();
  });

  sellBtn.addEventListener("click", ()=>{
    const idx=state.turrets.findIndex(tt=>tt.id===state.selectedTurretId);
    if(idx<0) return;
    const t=state.turrets[idx];
    const refund=Math.round(t.value*0.70);
    state.cash += refund;
    state.turrets.splice(idx,1);
    state.selectedTurretId=null;
    setMsg(`Sold for <b>$${refund}</b>.`, "ok");
    syncSelectedUI(); syncHUD();
  });

  // restart hold
  restartHoldBtn.addEventListener("mousedown", ()=>{
    state.holdActive=true;
    state.holdT=0;
  });
  window.addEventListener("mouseup", ()=>{ if(state.holdActive) cancelHold(); });
  restartHoldBtn.addEventListener("mouseleave", ()=>{ if(state.holdActive) cancelHold(); });

  // ---------- Loop ----------
  let last=performance.now();
  let timeAcc=0;

  function update(dt){
    if(!state.paused && !state.gameOver && !state.victory){
      spawnLogic(dt);
      moveEnemies(dt);
      turretLogic(dt);
      projectileLogic(dt);
      particlesLogic(dt);
      autoWaveTick(dt);
    }
    holdTick(dt);
    syncSelectedUI();
    syncHUD();
  }

  function loop(now){
    const rawDt=Math.min(0.033,(now-last)/1000);
    last=now;
    timeAcc += rawDt;

    const dt=rawDt * state.speed;
    update(dt);
    draw(timeAcc);

    requestAnimationFrame(loop);
  }

  // ---------- Map init ----------
  function init(){
    loadMap(0,false);
    setSpeed(1);
    setMsg(`<span class="ok"><b>Ready.</b></span> Build, then start Wave 1.`, "");
    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>
