<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Bignbot TD — Campaign Neon</title>
  <style>
    :root{
      --bg0:#050611; --bg1:#070a18;
      --text:#eaf1ff; --muted:#a9b7ff;
      --cyan:#28f0ff; --mag:#ff3bd4; --lime:#70ff6b; --yel:#ffe66d; --red:#ff5f77;
      --glass: rgba(10,14,34,0.72);
      --glass2: rgba(10,14,34,0.50);
      --line: rgba(255,255,255,0.16);
      --glowC: 0 0 18px rgba(40,240,255,0.24), 0 0 40px rgba(255,59,212,0.18);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      display:grid; place-items:center;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 420px at 50% 0%, rgba(255,59,212,0.18), transparent 60%),
        radial-gradient(900px 520px at 15% 80%, rgba(40,240,255,0.12), transparent 60%),
        radial-gradient(900px 520px at 85% 70%, rgba(112,255,107,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow:hidden;
    }
    .game-wrap{
      width:min(1240px, 98vw);
      padding:12px;
      position:relative;
    }
    canvas{
      width:100%;
      height:auto;
      border-radius:18px;
      border:1px solid var(--line);
      background:
        radial-gradient(900px 520px at 50% 30%, rgba(40,240,255,0.08), transparent 60%),
        linear-gradient(180deg, #060a16 0%, #050712 100%);
      box-shadow: 0 18px 70px rgba(0,0,0,0.58), var(--glowC);
      display:block;
      cursor:crosshair;
    }

    /* Scanlines */
    .scanlines{
      pointer-events:none;
      position:absolute; inset:12px;
      border-radius:18px;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px
      );
      mix-blend-mode: overlay;
      opacity:0.32;
    }

    /* HUD */
    .hud{
      position:absolute; left:12px; right:12px; top:12px; bottom:12px;
      pointer-events:none;
    }
    .hud-top{
      display:flex; justify-content:space-between; align-items:flex-start;
      gap:12px;
      padding:12px;
    }
    .hud-box{
      pointer-events:auto;
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
      box-shadow: var(--glowC);
      backdrop-filter: blur(8px);
      min-width: 220px;
    }
    .brand{
      font-weight:900; letter-spacing:0.5px;
      text-shadow: 0 0 18px rgba(40,240,255,0.30), 0 0 26px rgba(255,59,212,0.18);
    }
    .row{display:flex; justify-content:space-between; gap:10px; margin-top:6px; font-size:13px;}
    .big{font-size:18px; font-weight:900;}
    .muted{color:var(--muted)}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding:2px 8px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.32);
      font-size:12px;
    }

    /* Bottom build bar */
    .hud-bottom{
      position:absolute; left:0; right:0; bottom:0;
      padding:12px;
      display:flex; gap:12px; align-items:stretch;
      pointer-events:none;
    }
    .build-bar, .side-panel{
      pointer-events:auto;
      background: linear-gradient(180deg, var(--glass), var(--glass2));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow: var(--glowC);
      backdrop-filter: blur(10px);
    }
    .build-bar{
      flex:1;
      padding:10px;
      display:flex;
      gap:10px;
      align-items:stretch;
      overflow:auto;
    }
    .card{
      min-width: 220px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      padding:10px;
      cursor:pointer;
      transition: transform .06s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .card:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(40,240,255,0.55);
      box-shadow: 0 0 16px rgba(40,240,255,0.18), 0 0 18px rgba(255,59,212,0.10);
    }
    .card:active{ transform: translateY(1px); }
    .card.selected{
      border-color: rgba(255,59,212,0.85);
      box-shadow: 0 0 0 2px rgba(255,59,212,0.14) inset, 0 0 18px rgba(40,240,255,0.12);
    }
    .card h4{margin:0 0 6px 0; font-size:14px; font-weight:900; display:flex; justify-content:space-between; gap:10px;}
    .card .stat{font-size:12px; color:var(--muted); line-height:1.25;}
    .chip{
      display:inline-flex; align-items:center; justify-content:center;
      padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.30);
      font-size:12px;
      white-space:nowrap;
    }

    .side-panel{
      width: 340px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .btnrow{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
    button, select{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:var(--text);
      font-weight:900;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      outline:none;
    }
    button:hover, select:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(40,240,255,0.55);
      box-shadow: 0 0 14px rgba(40,240,255,0.18), 0 0 18px rgba(255,59,212,0.10);
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:0.45; cursor:not-allowed; }
    .seg{display:flex; gap:8px;}
    .seg button{ flex:1; }
    .seg .on{ border-color: rgba(255,59,212,0.85); box-shadow: 0 0 0 2px rgba(255,59,212,0.14) inset; }
    .danger{
      border-color: rgba(255,95,119,0.65) !important;
      box-shadow: 0 0 0 2px rgba(255,95,119,0.14) inset, 0 0 18px rgba(255,95,119,0.14);
    }
    .holdbar{
      height:8px; border-radius:999px;
      background: rgba(255,255,255,0.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.12);
    }
    .holdbar > div{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(255,95,119,0.9), rgba(255,59,212,0.9), rgba(40,240,255,0.9));
      transition: width 0.05s linear;
      box-shadow: 0 0 16px rgba(255,59,212,0.25);
    }
    .msg{
      font-size:13px; line-height:1.25;
      color:var(--muted);
      min-height: 34px;
    }
    .ok{color:var(--lime)} .bad{color:var(--red)} .warn{color:var(--yel)}
  </style>
</head>
<body>
  <div class="game-wrap">
    <canvas id="game" width="980" height="560"></canvas>
    <div class="scanlines"></div>

    <div class="hud">
      <div class="hud-top">
        <div class="hud-box">
          <div class="brand">Bignbot TD <span class="kbd">CAMPAIGN</span></div>
          <div class="row"><div class="muted">Map</div><div class="big" id="mapName"></div></div>
          <div class="row"><div class="muted">Wave</div><div class="big" id="waveText"></div></div>
        </div>

        <div class="hud-box" style="min-width:260px">
          <div class="row"><div class="muted">Cash</div><div class="big" id="cash"></div></div>
          <div class="row"><div class="muted">Lives</div><div class="big" id="lives"></div></div>
          <div class="row"><div class="muted">Next wave</div><div class="big" id="nextWave"></div></div>
        </div>

        <div class="hud-box" style="min-width:300px">
          <div class="muted" style="font-size:12px;margin-bottom:8px;">Controls</div>
          <div class="btnrow">
            <button id="pauseBtn">Pause</button>
            <button id="rangeBtn">Range: ON</button>
          </div>
          <div style="height:8px"></div>
          <div class="muted" style="font-size:12px;margin-bottom:6px;">Speed</div>
          <div class="seg">
            <button id="s1">1×</button>
            <button id="s2">2×</button>
            <button id="s3">3×</button>
            <button id="s4">4×</button>
          </div>
        </div>
      </div>

      <div class="hud-bottom">
        <div class="build-bar" id="buildBar"></div>

        <div class="side-panel">
          <div class="muted" style="font-size:12px;">Selected turret</div>
          <div class="hud-box" style="box-shadow:none" id="selectedBox">
            <div class="muted">None</div>
          </div>

          <div class="btnrow">
            <button id="upgradeBtn" disabled>Upgrade</button>
            <button id="sellBtn" disabled>Sell</button>
          </div>

          <div class="msg" id="msg"></div>

          <button id="restartHold" class="danger">HOLD TO RESTART (1.2s)</button>
          <div class="holdbar"><div id="holdFill"></div></div>

          <div class="muted" style="font-size:12px;margin-top:4px;">
            Waves auto-start <b>30s</b> after clear. Beat all maps to win.
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // HUD elements
  const elMapName = document.getElementById("mapName");
  const elWaveText = document.getElementById("waveText");
  const elCash = document.getElementById("cash");
  const elLives = document.getElementById("lives");
  const elNextWave = document.getElementById("nextWave");
  const elMsg = document.getElementById("msg");
  const buildBar = document.getElementById("buildBar");
  const selectedBox = document.getElementById("selectedBox");
  const pauseBtn = document.getElementById("pauseBtn");
  const rangeBtn = document.getElementById("rangeBtn");
  const upgradeBtn = document.getElementById("upgradeBtn");
  const sellBtn = document.getElementById("sellBtn");

  const s1 = document.getElementById("s1");
  const s2 = document.getElementById("s2");
  const s3 = document.getElementById("s3");
  const s4 = document.getElementById("s4");

  const restartHoldBtn = document.getElementById("restartHold");
  const holdFill = document.getElementById("holdFill");

  // helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
  const PATH_WIDTH = 50;

  function setMsg(html, tone="") {
    if (!html) { elMsg.innerHTML = ""; return; }
    elMsg.innerHTML = `<span class="${tone}">${html}</span>`;
  }

  function linePointDistance(px,py, ax,ay, bx,by) {
    const vx = bx-ax, vy = by-ay;
    const wx = px-ax, wy = py-ay;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px-ax, py-ay);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px-bx, py-by);
    const t = c1 / c2;
    const projx = ax + t*vx, projy = ay + t*vy;
    return Math.hypot(px-projx, py-projy);
  }

  function getMousePos(evt) {
    const r = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - r.left) * (canvas.width / r.width),
      y: (evt.clientY - r.top) * (canvas.height / r.height),
    };
  }

  // Campaign maps (no user selection)
  const MAPS = [
    {
      key:"training",
      name:"Training Grounds",
      path:[{x:46,y:280},{x:210,y:280},{x:210,y:140},{x:460,y:140},{x:460,y:420},{x:700,y:420},{x:700,y:240},{x:920,y:240}],
      startingCash:170, startingLives:22
    },
    {
      key:"crossroads",
      name:"Crossroads",
      path:[{x:46,y:110},{x:280,y:110},{x:280,y:290},{x:140,y:290},{x:140,y:460},{x:560,y:460},{x:560,y:220},{x:920,y:220}],
      startingCash:180, startingLives:20
    },
    {
      key:"spiral",
      name:"Spiral Run",
      path:[{x:46,y:460},{x:880,y:460},{x:880,y:120},{x:160,y:120},{x:160,y:360},{x:740,y:360},{x:740,y:190},{x:320,y:190},{x:320,y:300},{x:920,y:300}],
      startingCash:190, startingLives:18
    }
  ];

  // Turrets
  const TURRET_TYPES = {
    basic: { name:"Basic", desc:"Balanced.", cost:60, range:145, damage:14, cooldown:0.52, projSpeed:460, pierce:1, splash:0, color:"#28f0ff" },
    rapid: { name:"Rapid", desc:"Fast shots.", cost:90, range:120, damage:7,  cooldown:0.16, projSpeed:560, pierce:1, splash:0, color:"#70ff6b" },
    sniper:{ name:"Sniper",desc:"Long range.", cost:135,range:260, damage:52, cooldown:1.25, projSpeed:780, pierce:1, splash:0, color:"#ff3bd4" },
    splash:{ name:"Splash",desc:"AOE mortar.", cost:120,range:165, damage:20, cooldown:0.82, projSpeed:380, pierce:1, splash:58, color:"#ffe66d" },
  };

  let nextId = 1;

  const state = {
    mapIdx: 0,
    path: MAPS[0].path,
    waves: [],
    waveIdx: 0,
    inWave: false,
    spawnTimer: 0,
    spawned: 0,
    waveGap: 0.42,

    enemies: [],
    turrets: [],
    projectiles: [],
    particles: [],
    flashes: [],

    cash: 0,
    lives: 0,

    paused: false,
    victory: false,
    gameOver: false,

    showRanges: true,
    speed: 1,

    selectedTurretType: "basic",
    selectedTurretId: null,

    // Auto wave delay (30s)
    autoTimer: 0,     // counts down between waves
    autoDelay: 30,

    // restart hold
    holdActive:false,
    holdT:0,
    holdNeed:1.2,
  };

  function currentMap(){ return MAPS[state.mapIdx]; }

  function generateWaves(mapKey){
    const bias = mapKey==="training"?0.95:(mapKey==="crossroads"?1.0:1.06);
    const waves = [];
    for (let i=1;i<=25;i++){
      const isBoss = (i % 5 === 0);
      const tier = i;
      const countBase = Math.round(10 + tier*1.2);
      const hpBase = 42 + tier*10;
      const speedBase = 55 + tier*1.2;

      const armored = (tier >= 8 && (tier % 3 === 2));
      const fast = (tier >= 6 && (tier % 4 === 1));
      const swarm = (tier >= 10 && (tier % 4 === 3));

      let count = countBase;
      let hp = hpBase;
      let speed = speedBase;

      if (swarm) { count = Math.round(count*1.6); hp = Math.round(hp*0.72); speed = Math.round(speed*1.05); }
      if (fast)  { speed = Math.round(speed*1.28); hp = Math.round(hp*0.88); }
      if (armored){ hp = Math.round(hp*1.25); }

      if (isBoss) {
        count = 1;
        hp = Math.round((hpBase * 8.5) * bias);
        speed = Math.round((speedBase * 0.68));
      } else {
        hp = Math.round(hp * bias);
      }

      const reward = isBoss ? (80 + tier*6) : (11 + Math.floor(tier/2));
      waves.push({count,hp,speed,reward,boss:isBoss,armored:isBoss?true:armored,fast:isBoss?false:fast});
    }
    return waves;
  }

  function pointOnPath(px,py){
    const path = state.path;
    for (let i=0;i<path.length-1;i++){
      const a=path[i], b=path[i+1];
      if (linePointDistance(px,py,a.x,a.y,b.x,b.y) <= PATH_WIDTH/2) return true;
    }
    return false;
  }

  function turretAt(px,py){
    for (const t of state.turrets){
      if (dist(px,py,t.x,t.y) <= t.r+8) return t;
    }
    return null;
  }

  function makeEnemy(wave){
    const r = wave.boss ? 18 : (wave.fast ? 9 : 12);
    return {
      id: nextId++,
      x: state.path[0].x,
      y: state.path[0].y,
      r,
      hp: wave.hp,
      maxHp: wave.hp,
      speed: wave.fast ? wave.speed*1.15 : wave.speed,
      reward: wave.reward,
      armored: !!wave.armored,
      boss: !!wave.boss,
      pathIdx: 0,
      alive: true
    };
  }

  function makeTurret(x,y,typeKey){
    const def = TURRET_TYPES[typeKey];
    const t = {
      id: nextId++,
      type:typeKey,
      x,y,
      r:16,
      angle:0,
      cooldown:0,
      level:1,
      baseRange:def.range,
      baseDamage:def.damage,
      baseCooldown:def.cooldown,
      baseProjSpeed:def.projSpeed,
      splash:def.splash,
      pierce:def.pierce,
      range:def.range,
      damage:def.damage,
      fireCd:def.cooldown,
      projSpeed:def.projSpeed,
      value:def.cost,
    };
    applyUpgrade(t);
    return t;
  }

  function makeProjectile(x,y,vx,vy,dmg,splash,pierce,color){
    return {x,y,vx,vy,dmg,splash,pierce,color,alive:true,hitIds:new Set(),life:2.8};
  }

  function addParticle(x,y,vx,vy,life,color){
    state.particles.push({x,y,vx,vy,life,maxLife:life,color});
  }

  function upgradeCost(t){
    const base = TURRET_TYPES[t.type].cost;
    return Math.round(base * (t.level===1 ? 0.75 : 1.10));
  }
  function applyUpgrade(t){
    const lvl=t.level;
    const dmgMult = 1 + 0.50*(lvl-1);
    const rangeMult= 1 + 0.12*(lvl-1);
    const cdMult   = Math.pow(0.86,(lvl-1));
    t.damage = t.baseDamage * dmgMult;
    t.range  = t.baseRange  * rangeMult;
    t.fireCd = t.baseCooldown * cdMult;
    t.projSpeed = t.baseProjSpeed;
  }

  function syncHUD(){
    elMapName.textContent = currentMap().name;
    elCash.textContent = `$${state.cash}`;
    elLives.textContent = `${state.lives}`;

    const waveNow = Math.min(state.waveIdx + (state.inWave?1:0), state.waves.length);
    elWaveText.textContent = `${waveNow}/25`;

    if (state.gameOver) elNextWave.textContent = "—";
    else if (state.victory) elNextWave.textContent = "DONE";
    else if (state.inWave) elNextWave.textContent = "IN WAVE";
    else elNextWave.textContent = `${Math.ceil(state.autoTimer)}s`;

    pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    rangeBtn.textContent = `Range: ${state.showRanges ? "ON" : "OFF"}`;

    // speed highlight
    [s1,s2,s3,s4].forEach(b=>b.classList.remove("on"));
    ({1:s1,2:s2,3:s3,4:s4}[state.speed]).classList.add("on");
  }

  function syncSelectedUI(){
    const t = state.turrets.find(tt => tt.id===state.selectedTurretId);
    if (!t){
      selectedBox.innerHTML = `<div class="muted">None (click a turret)</div>`;
      upgradeBtn.disabled = true;
      sellBtn.disabled = true;
      return;
    }
    const def = TURRET_TYPES[t.type];
    selectedBox.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
        <div>
          <div style="font-weight:900">${def.name} <span class="muted">Lv ${t.level}/3</span></div>
          <div class="muted" style="font-size:12px;line-height:1.25">
            DMG ${t.damage.toFixed(1)} • RNG ${Math.round(t.range)} • CD ${t.fireCd.toFixed(2)}${t.splash?` • AOE ${t.splash}`:""}
          </div>
        </div>
        <div class="kbd">Upg: ${t.level>=3 ? "MAX" : `$${upgradeCost(t)}`}</div>
      </div>`;
    upgradeBtn.disabled = state.gameOver || state.victory || t.level>=3;
    sellBtn.disabled = state.gameOver || state.victory;
  }

  function buildBuildBar(){
    buildBar.innerHTML = "";
    Object.entries(TURRET_TYPES).forEach(([key,def])=>{
      const div = document.createElement("div");
      div.className = "card" + (state.selectedTurretType===key ? " selected" : "");
      div.innerHTML = `
        <h4>
          <span>${def.name}</span>
          <span class="chip">$${def.cost}</span>
        </h4>
        <div class="stat">DMG ${def.damage} • RNG ${def.range} • CD ${def.cooldown.toFixed(2)}${def.splash?` • AOE ${def.splash}`:""}</div>
        <div class="stat">${def.desc}</div>
      `;
      div.addEventListener("click", ()=>{
        state.selectedTurretType = key;
        buildBuildBar();
        setMsg(`Selected <b>${def.name}</b>. Click the field to place.`, "");
      });
      buildBar.appendChild(div);
    });
  }

  function startWave(){
    if (state.gameOver || state.victory || state.inWave) return;
    if (state.waveIdx >= state.waves.length) return;

    state.inWave = true;
    state.spawnTimer = 0;
    state.spawned = 0;
    state.waveGap = clamp(0.60 - state.waveIdx*0.014, 0.18, 0.60);

    setMsg(`Wave <b>${state.waveIdx+1}</b> started.`, "ok");
    syncHUD();
  }

  function resetCampaign(){
    state.mapIdx = 0;
    loadMap(0, false);
    setMsg("Campaign started. Place turrets. Waves auto-start.", "ok");
  }

  function loadMap(idx, carry){
    state.mapIdx = idx;
    state.path = MAPS[idx].path;
    state.waves = generateWaves(MAPS[idx].key);
    state.waveIdx = 0;
    state.inWave = false;
    state.spawnTimer = 0;
    state.spawned = 0;

    state.enemies = [];
    state.turrets = [];
    state.projectiles = [];
    state.particles = [];
    state.flashes = [];

    state.gameOver = false;
    state.victory = false;
    state.paused = false;

    state.selectedTurretId = null;

    if (!carry){
      state.cash = MAPS[idx].startingCash;
      state.lives = MAPS[idx].startingLives;
    } else {
      // small “map arrival bonus”
      state.cash += 65;
      state.lives = Math.min(state.lives + 2, 30);
    }

    state.autoTimer = state.autoDelay; // first wave starts after 30s
    buildBuildBar();
    syncSelectedUI();
    syncHUD();
  }

  function advanceMap(){
    if (state.mapIdx < MAPS.length-1){
      const next = state.mapIdx + 1;
      setMsg(`<b class="ok">MAP CLEARED!</b> Loading <b>${MAPS[next].name}</b>…`, "");
      loadMap(next, true);
    } else {
      state.victory = true;
      setMsg(`<b class="ok">CAMPAIGN VICTORY!</b> You cleared all maps.`, "");
    }
    syncHUD();
  }

  // placement + selection
  canvas.addEventListener("click",(evt)=>{
    if (state.gameOver || state.victory) return;
    const {x,y} = getMousePos(evt);

    // select turret
    const hit = turretAt(x,y);
    if (hit){
      state.selectedTurretId = hit.id;
      setMsg(`Selected <b>${TURRET_TYPES[hit.type].name}</b>.`, "");
      syncSelectedUI();
      return;
    }

    // place turret
    if (pointOnPath(x,y)){ setMsg("Can't place on the path.", "bad"); return; }
    for (const t of state.turrets){
      if (dist(x,y,t.x,t.y) < (t.r + 18)){ setMsg("Too close to another turret.", "bad"); return; }
    }
    const def = TURRET_TYPES[state.selectedTurretType];
    if (state.cash < def.cost){ setMsg("Not enough cash.", "bad"); return; }

    state.cash -= def.cost;
    state.turrets.push(makeTurret(x,y,state.selectedTurretType));
    setMsg(`Placed <b>${def.name}</b>.`, "ok");
    syncHUD();
  });

  // buttons
  pauseBtn.addEventListener("click", ()=>{ state.paused = !state.paused; syncHUD(); });
  rangeBtn.addEventListener("click", ()=>{ state.showRanges = !state.showRanges; syncHUD(); });

  function setSpeed(n){ state.speed = n; syncHUD(); }
  s1.addEventListener("click",()=>setSpeed(1));
  s2.addEventListener("click",()=>setSpeed(2));
  s3.addEventListener("click",()=>setSpeed(3));
  s4.addEventListener("click",()=>setSpeed(4));

  upgradeBtn.addEventListener("click", ()=>{
    const t = state.turrets.find(tt => tt.id===state.selectedTurretId);
    if (!t) return;
    if (t.level>=3){ setMsg("Max level.", "warn"); return; }
    const cost = upgradeCost(t);
    if (state.cash < cost){ setMsg("Not enough cash to upgrade.", "bad"); return; }
    state.cash -= cost;
    t.level++; t.value += cost;
    applyUpgrade(t);
    setMsg(`Upgraded <b>${TURRET_TYPES[t.type].name}</b> to Lv ${t.level}.`, "ok");
    syncSelectedUI(); syncHUD();
  });

  sellBtn.addEventListener("click", ()=>{
    const idx = state.turrets.findIndex(tt => tt.id===state.selectedTurretId);
    if (idx === -1) return;
    const t = state.turrets[idx];
    const refund = Math.round(t.value * 0.70);
    state.cash += refund;
    state.turrets.splice(idx,1);
    state.selectedTurretId = null;
    setMsg(`Sold for $${refund}.`, "ok");
    syncSelectedUI(); syncHUD();
  });

  // Restart hold
  function setHoldUI(){
    const pct = clamp(state.holdT/state.holdNeed,0,1);
    holdFill.style.width = `${Math.round(pct*100)}%`;
  }
  function cancelHold(){
    state.holdActive=false; state.holdT=0; setHoldUI();
  }
  restartHoldBtn.addEventListener("mousedown", ()=>{
    state.holdActive=true; state.holdT=0;
    setMsg("Holding… keep holding to restart campaign.", "warn");
  });
  window.addEventListener("mouseup", ()=>{ if (state.holdActive) { cancelHold(); } });
  restartHoldBtn.addEventListener("mouseleave", ()=>{ if (state.holdActive) cancelHold(); });

  // Combat
  function findBestTarget(t){
    let best=null, bestScore=-Infinity;
    for (const e of state.enemies){
      const d = dist(t.x,t.y,e.x,e.y);
      if (d > t.range) continue;
      const score = e.pathIdx*10000 - d;
      if (score>bestScore){ bestScore=score; best=e; }
    }
    return best;
  }

  function spawnLogic(dt){
    if (!state.inWave) return;
    const wave = state.waves[state.waveIdx];
    state.spawnTimer -= dt;

    if (state.spawned < wave.count && state.spawnTimer <= 0){
      state.enemies.push(makeEnemy(wave));
      state.spawned++;
      state.spawnTimer = state.waveGap;
    }

    if (state.spawned >= wave.count && state.enemies.length === 0){
      state.inWave = false;
      state.waveIdx++;

      if (state.waveIdx >= state.waves.length){
        // map cleared -> next map
        setMsg(`<b class="ok">All 25 waves cleared!</b>`, "");
        advanceMap();
      } else {
        state.autoTimer = state.autoDelay; // 30s until next wave
        setMsg(`Wave cleared. Next wave in <b>${state.autoDelay}s</b>.`, "ok");
      }
      syncHUD();
    }
  }

  function moveEnemies(dt){
    const path = state.path;
    for (const e of state.enemies){
      const a = path[e.pathIdx];
      const b = path[e.pathIdx+1];
      if (!b){
        state.lives -= 1;
        e.alive = false;
        continue;
      }
      const dx=b.x-e.x, dy=b.y-e.y;
      const d=Math.hypot(dx,dy);
      if (d < 0.001){ e.pathIdx++; continue; }
      const step=e.speed*dt;
      const nx=dx/d, ny=dy/d;
      if (step>=d){ e.x=b.x; e.y=b.y; e.pathIdx++; }
      else { e.x += nx*step; e.y += ny*step; }
    }
    state.enemies = state.enemies.filter(e => e.alive && e.hp>0);

    if (state.lives <= 0 && !state.gameOver){
      state.lives = 0;
      state.gameOver = true;
      state.inWave = false;
      setMsg(`<b class="bad">GAME OVER.</b> Hold restart to retry.`, "");
      syncHUD(); syncSelectedUI();
    }
  }

  function turretLogic(dt){
    for (const t of state.turrets){
      t.cooldown -= dt;
      if (t.cooldown > 0) continue;

      const target = findBestTarget(t);
      if (!target) continue;

      const dx=target.x-t.x, dy=target.y-t.y;
      t.angle = Math.atan2(dy,dx);

      const d=Math.hypot(dx,dy) || 1;
      const vx=(dx/d)*t.projSpeed, vy=(dy/d)*t.projSpeed;
      const color = TURRET_TYPES[t.type].color;

      state.projectiles.push(makeProjectile(
        t.x + Math.cos(t.angle)*20,
        t.y + Math.sin(t.angle)*20,
        vx,vy,
        t.damage,
        t.splash,
        t.pierce,
        color
      ));

      state.flashes.push({x:t.x,y:t.y,a:t.angle,life:0.09,color});
      t.cooldown = t.fireCd;
    }
  }

  function projectileLogic(dt){
    for (const p of state.projectiles){
      p.life -= dt;
      if (p.life <= 0){ p.alive=false; continue; }

      const px0=p.x, py0=p.y;
      p.x += p.vx*dt; p.y += p.vy*dt;

      if (p.x < -60 || p.x > W+60 || p.y < -60 || p.y > H+60){ p.alive=false; continue; }

      for (const e of state.enemies){
        if (p.pierce <= 0) break;
        if (p.hitIds.has(e.id)) continue;

        if (dist(p.x,p.y,e.x,e.y) <= e.r+5){
          p.hitIds.add(e.id);
          const dmg = e.armored ? p.dmg*0.78 : p.dmg;
          e.hp -= dmg;

          for (let i=0;i<7;i++){
            const ang=Math.random()*Math.PI*2;
            const sp=90+Math.random()*160;
            addParticle(e.x,e.y,Math.cos(ang)*sp,Math.sin(ang)*sp,0.18+Math.random()*0.18,"rgba(40,240,255,0.95)");
          }

          if (p.splash > 0){
            for (const e2 of state.enemies){
              if (e2.id===e.id) continue;
              if (dist(e.x,e.y,e2.x,e2.y) <= p.splash){
                const dmg2 = e2.armored ? p.dmg*0.62 : p.dmg*0.84;
                e2.hp -= dmg2;
              }
            }
            for (let i=0;i<16;i++){
              const ang=(i/16)*Math.PI*2;
              addParticle(e.x + Math.cos(ang)*6, e.y + Math.sin(ang)*6, Math.cos(ang)*160, Math.sin(ang)*160, 0.22, "rgba(255,59,212,0.85)");
            }
          }

          if (e.hp <= 0){
            state.cash += e.reward + (e.boss ? 50 : 0);
            for (let i=0;i<18;i++){
              const ang=Math.random()*Math.PI*2;
              const sp=100+Math.random()*220;
              addParticle(e.x,e.y,Math.cos(ang)*sp,Math.sin(ang)*sp,0.28+Math.random()*0.22,"rgba(255,230,109,0.95)");
            }
          }

          p.pierce -= 1;
          if (p.pierce <= 0) p.alive=false;
        }
      }

      // trail
      if (Math.random()<0.85){
        addParticle(px0,py0,(p.vx*-0.03),(p.vy*-0.03),0.10,"rgba(255,255,255,0.75)");
      }
    }
    state.projectiles = state.projectiles.filter(p=>p.alive);
  }

  function particlesLogic(dt){
    for (const q of state.particles){
      q.life -= dt;
      if (q.life <= 0) continue;
      q.x += q.vx*dt; q.y += q.vy*dt;
      q.vx *= (1-2.4*dt); q.vy *= (1-2.4*dt);
    }
    state.particles = state.particles.filter(q=>q.life>0);

    for (const f of state.flashes) f.life -= dt;
    state.flashes = state.flashes.filter(f=>f.life>0);
  }

  // Drawing
  function drawNeonGrid(t){
    const step=42;
    const ox=(t*18)%step, oy=(t*12)%step;
    ctx.globalAlpha=0.12; ctx.lineWidth=1;
    for (let x=-step;x<=W+step;x+=step){
      ctx.strokeStyle="rgba(40,240,255,0.35)";
      ctx.beginPath(); ctx.moveTo(x+ox,0); ctx.lineTo(x+ox,H); ctx.stroke();
    }
    for (let y=-step;y<=H+step;y+=step){
      ctx.strokeStyle="rgba(255,59,212,0.25)";
      ctx.beginPath(); ctx.moveTo(0,y+oy); ctx.lineTo(W,y+oy); ctx.stroke();
    }
    ctx.globalAlpha=1;
  }

  function drawPath(){
    const path=state.path;
    ctx.lineCap="round"; ctx.lineJoin="round";
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.lineWidth=PATH_WIDTH;
    ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y);
    for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
    ctx.stroke();

    ctx.strokeStyle="rgba(40,240,255,0.22)";
    ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y);
    for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
    ctx.stroke();

    const s=path[0], e=path[path.length-1];
    ctx.fillStyle="rgba(112,255,107,0.14)";
    ctx.beginPath(); ctx.arc(s.x,s.y,16,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,95,119,0.18)";
    ctx.beginPath(); ctx.arc(e.x,e.y,18,0,Math.PI*2); ctx.fill();
  }

  function drawParticles(){
    for (const q of state.particles){
      const a=clamp(q.life/q.maxLife,0,1);
      ctx.globalAlpha=a;
      ctx.fillStyle=q.color;
      ctx.beginPath(); ctx.arc(q.x,q.y,1.7,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  function drawProjectiles(){
    for (const p of state.projectiles){
      ctx.strokeStyle=p.color;
      ctx.globalAlpha=0.85;
      ctx.lineWidth=2.6;
      ctx.beginPath();
      ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
      ctx.lineTo(p.x,p.y);
      ctx.stroke();
      ctx.globalAlpha=1;

      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.beginPath(); ctx.arc(p.x,p.y,2.5,0,Math.PI*2); ctx.fill();
    }
  }

  function drawEnemies(){
    for (const e of state.enemies){
      ctx.shadowColor = e.boss ? "rgba(255,230,109,0.85)" : "rgba(40,240,255,0.75)";
      ctx.shadowBlur = e.boss ? 18 : 12;
      ctx.fillStyle = e.boss ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.86)";
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=0;

      if (e.armored){
        ctx.strokeStyle="rgba(255,230,109,0.80)";
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+2,0,Math.PI*2); ctx.stroke();
      }

      const w=e.boss?60:38, h=7;
      const x=e.x-w/2, y=e.y-e.r-16;
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.fillRect(x,y,w,h);
      const hpPct=clamp(e.hp/e.maxHp,0,1);
      ctx.fillStyle=e.boss?"rgba(255,59,212,0.85)":"rgba(40,240,255,0.70)";
      ctx.fillRect(x,y,w*hpPct,h);
      ctx.globalAlpha=1;
    }
  }

  function drawTurret(t){
    const def=TURRET_TYPES[t.type];
    const c=def.color;

    if (state.showRanges){
      ctx.globalAlpha=0.08;
      ctx.fillStyle=c;
      ctx.beginPath(); ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }

    ctx.save();
    ctx.translate(t.x,t.y);

    // base hex
    const baseR=t.r+2;
    ctx.shadowColor=c; ctx.shadowBlur=14;
    ctx.fillStyle="rgba(10,14,34,0.92)";
    ctx.strokeStyle=c;
    ctx.lineWidth=(state.selectedTurretId===t.id)?4.5:3;

    ctx.beginPath();
    for (let i=0;i<6;i++){
      const a=(Math.PI*2)*(i/6)+Math.PI/6;
      const x=Math.cos(a)*baseR, y=Math.sin(a)*baseR;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha=0.92;
    ctx.stroke();
    ctx.globalAlpha=1;

    ctx.shadowBlur=0;
    ctx.strokeStyle="rgba(255,255,255,0.22)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.stroke();

    // body
    ctx.rotate(t.angle);
    const bodyRect=(w,h,a)=>{ ctx.fillStyle=`rgba(255,255,255,${a})`; ctx.fillRect(-w/2,-h/2,w,h); };

    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.fillRect(-10,-6,20,12);

    if (t.type==="basic"){
      bodyRect(16,10,0.14);
      ctx.fillStyle="rgba(255,255,255,0.80)"; ctx.fillRect(4,-2,18,4);
      ctx.fillStyle=c; ctx.fillRect(14,-1,10,2);
    } else if (t.type==="rapid"){
      bodyRect(18,12,0.12);
      ctx.fillStyle="rgba(255,255,255,0.78)";
      ctx.fillRect(4,-5,16,3); ctx.fillRect(4,2,16,3);
      ctx.fillStyle=c; ctx.fillRect(14,-4,8,1.5); ctx.fillRect(14,3,8,1.5);
    } else if (t.type==="sniper"){
      bodyRect(18,10,0.10);
      ctx.fillStyle="rgba(255,255,255,0.82)"; ctx.fillRect(4,-1.8,28,3.6);
      ctx.fillStyle=c; ctx.fillRect(-2,-7,10,3);
      ctx.strokeStyle="rgba(255,255,255,0.45)"; ctx.lineWidth=1; ctx.strokeRect(-2,-7,10,3);
    } else if (t.type==="splash"){
      bodyRect(18,12,0.10);
      ctx.strokeStyle="rgba(255,255,255,0.65)"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(10,0,9,-Math.PI/2,Math.PI/2); ctx.stroke();
      ctx.fillStyle=c; ctx.fillRect(6,-1,10,2);
    }

    ctx.rotate(-t.angle);
    ctx.shadowBlur=10;
    for (let i=0;i<t.level;i++){
      ctx.fillStyle=c; ctx.globalAlpha=0.9;
      ctx.beginPath(); ctx.arc(-12 + i*12, 20, 3.2, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;

    ctx.restore();
  }

  function drawFlashes(){
    for (const f of state.flashes){
      const a=clamp(f.life/0.09,0,1);
      ctx.globalAlpha=a;
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(f.x + Math.cos(f.a)*24, f.y + Math.sin(f.a)*24, 5.5, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha=1;
    }
  }

  function drawHUDText(t){
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const status = state.gameOver ? "GAME OVER" : (state.victory ? "VICTORY" : (state.paused ? "PAUSED" : "RUN"));
    ctx.fillText(`MAP ${state.mapIdx+1}/${MAPS.length}  |  ENEMIES ${state.enemies.length}  |  SPEED ${state.speed}x  |  ${status}`, 14, 18);
  }

  function draw(t){
    ctx.clearRect(0,0,W,H);
    drawNeonGrid(t);
    drawPath();
    drawParticles();
    drawProjectiles();
    drawEnemies();
    for (const turr of state.turrets) drawTurret(turr);
    drawFlashes();
    drawHUDText(t);
  }

  // Auto wave timer tick (starts waves automatically)
  function autoWaveTick(dt){
    if (state.gameOver || state.victory) return;
    if (state.inWave) return;
    if (state.waveIdx >= state.waves.length) return;

    state.autoTimer -= dt;
    if (state.autoTimer <= 0){
      state.autoTimer = 0;
      startWave();
    }
  }

  // Restart hold tick
  function holdTick(dt){
    if (!state.holdActive) return;
    state.holdT += dt;
    const pct = clamp(state.holdT/state.holdNeed,0,1);
    holdFill.style.width = `${Math.round(pct*100)}%`;
    if (state.holdT >= state.holdNeed){
      state.holdActive=false;
      state.holdT=0;
      holdFill.style.width="0%";
      resetCampaign();
    }
  }

  // Loop
  let last = performance.now();
  let timeAcc = 0;

  function update(dt){
    if (!state.paused && !state.gameOver && !state.victory){
      spawnLogic(dt);
      moveEnemies(dt);
      turretLogic(dt);
      projectileLogic(dt);
      particlesLogic(dt);
      autoWaveTick(dt);
    }
    holdTick(dt);
    syncHUD();
  }

  function loop(now){
    const rawDt = Math.min(0.033, (now-last)/1000);
    last = now;

    const dt = rawDt * state.speed;
    timeAcc += rawDt;

    update(dt);
    draw(timeAcc);

    requestAnimationFrame(loop);
  }

  // init
  function init(){
    state.cash = MAPS[0].startingCash;
    state.lives = MAPS[0].startingLives;
    state.waves = generateWaves(MAPS[0].key);
    state.autoTimer = state.autoDelay;

    buildBuildBar();
    syncSelectedUI();
    syncHUD();
    setMsg("Campaign online. Waves start automatically. Place turrets now.", "ok");
    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>
